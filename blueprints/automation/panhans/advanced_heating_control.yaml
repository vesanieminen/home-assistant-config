blueprint:
  name: "\U0001F525 Advanced Heating Control V5"
  author: panhans
  homeassistant:
    min_version: 2024.10.0
  description: "\U0001F525 room based heating / ❄ based on\n\n> \U0001F465 people
    presence\n\U0001F5D3️ multiple schedulers\n\U0001F6B6 presence sensor\n↔️ proximity
    aka geo fencing\n\n\U0001F976 frost protection\n\U0001F621 adjustable aggressive
    mode\n\U0001F324️ activation based on weather, temperature or boolean entities\n\U0001F39B️
    granular schedule adjustments\n\U0001FA9F multiple window open detection\n\U0001F388
    party mode\n\U0001F91D guest mode\n⚔️ liming protection\n\U0001F4CD dynamic valve
    positioning\n\U0001F9ED thermostat calibration for the most common devices (Tado,
    Aqara, Popp / Danfoss / Hive, Tuya)\n⚙️ several tweaks for fixing your thermostat
    issues\n\U0001F3AC custom action\n\U0001F92B calm & \U0001F4AA reliable\n\n\n**Version**:
    5.2.11\n**Help & FAQ**: [Advanced Heating Control](https://community.home-assistant.io/t/advanced-heating-control/469873)\n**Documentation:**
    [panhans.github.io/HomeAssistant/](https://panhans.github.io/HomeAssistant/)\n\n[![ko-fi](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/Q5Q3QEH52)\n"
  source_url: https://github.com/panhans/HomeAssistant/blob/main/blueprints/automation/panhans/advanced_heating_control.yaml
  domain: automation
  input:
    thermostat_section:
      name: Thermostats & Sensors
      icon: mdi:thermostat
      input:
        input_trvs:
          name: "\U0001F525 Thermostats / Climates"
          description: "`thermostats` `climates` \n\n[Thermostats / Climates](https://www.home-assistant.io/integrations/climate/)
            to be controlled.\n"
          selector:
            entity:
              filter:
              - domain:
                - climate
              multiple: true
        input_hvac_mode:
          name: "\U0001F39B️ Operation / HVAC Mode"
          description: '`hvac`


            Select the hvac mode for your [thermostats](https://www.home-assistant.io/integrations/climate/).
            Be sure your selected thermostats support the hvac mode you''ve chosen.
            AHC will log a warning if there is a miss match. For radiator [thermostats]((https://www.home-assistant.io/integrations/climate/))
            the default is mostly *heat*. If you own an air conditioner it will support
            *auto* or *cool*, too.

            '
          default: heat
          selector:
            select:
              options:
              - heat
              - cool
              - auto
              - heat_cool
              multiple: false
              custom_value: false
              sort: false
        input_temperature_sensor:
          name: "\U0001F321️ Room Temperature Sensor"
          description: "`calibration` `aggressive mode` `optional`\n\nFor some features
            an external temperature sensor is reqired, e.g. calibration.\nTemperature
            calibration for your [thermostats](https://www.home-assistant.io/integrations/climate/).
            The following is supported:\n\n  * Tado, Aqara, Popp, Danfoss, Hive, Tuya\n
            \ * generic calibration\n\nNote: This is an additional sensor inside your
            room usually next to your favourite spot. [Thermostats](https://www.home-assistant.io/integrations/climate/)
            or its integration (e.g. Z2M or ZHA) except Tado should provide a seperate
            calibration entity.\n"
          default: []
          selector:
            entity:
              filter:
              - domain:
                - sensor
                device_class:
                - temperature
              multiple: false
    temperature_section:
      name: Temperatures
      icon: mdi:thermometer
      collapsed: true
      input:
        input_temperature_comfort_static:
          name: "\U0001F6CB️ Static Comfort Temperature"
          description: '`comfort temperature`


            You can set a static comfort temperature here.

            '
          default: 22
          selector:
            number:
              min: 12.0
              max: 86.0
              step: 0.5
              mode: box
              unit_of_measurement: °C / °F
        input_temperature_eco_static:
          name: "\U0001F331 Static Eco Temperature"
          description: '`eco temperature`


            The temperature that is set when your heating schedule is not active.

            '
          default: 19
          selector:
            number:
              min: 4.0
              max: 75.0
              step: 0.5
              mode: box
              unit_of_measurement: °C / °F
        input_temperature_comfort:
          name: "\U0001F6CB️ Comfort Temperature"
          description: '`comfort temperature` `optional`


            To control your comfort temperature via automations or the UI, you can
            specify an *[input_number](https://www.home-assistant.io/integrations/input_number/)*
            entity here.


            Create your helper [here](https://my.home-assistant.io/redirect/helpers/).

            '
          default: []
          selector:
            entity:
              filter:
              - domain:
                - input_number
              multiple: false
        input_temperature_eco:
          name: "\U0001F331 Eco Temperature"
          description: '`eco temperature` `optional`


            To control your eco temperature via automations or the UI, you can specify
            an *[input_number](https://www.home-assistant.io/integrations/input_number/)*
            entity here.


            Create your helper [here](https://my.home-assistant.io/redirect/helpers/).

            '
          default: []
          selector:
            entity:
              filter:
              - domain:
                - input_number
              multiple: false
    adjustment_section:
      name: Adjustments / Heating Plan
      icon: mdi:sun-clock
      collapsed: true
      input:
        input_adjustments:
          name: "\U0001F39B️ Heating Schedule Adjustments"
          description: "`optional`\n\nHere you can setup some adjustments to your
            heating schedule.<br/><br/> *Note*: Here you can set values for eco or
            comfort temperature. The switch between those target temperatures is controled
            by schedules, presence sensors, proximity, ect. <br/>\n<details> <summary><code><strong>CLICK
            HERE:</strong> Modifiers</code></summary> <br/>\n\n> \U0001F554 **time**\n>
            Timestamp when the adjustment should kick in. (required)\n\n> \U0001F4C6
            **days**\n> Select days where this setting shall be enabled.\n> ['Mon','Tue','Wed','Thu','Fri','Sat','Sun']\n\n>
            \U0001F5D3️ **scheduler**\n> Only enable this entry if this string is
            part of the name of your active scheduler.\n\n> \U0001F6CB️ **comfort**\n>
            Adjust comfort temperature\n\n> \U0001F331 **eco**\n> Adjust eco temperature\n\n>
            \U0001F9ED **calibration**\n> Toggle calibration \n> on/off\n\n</details>\n<br/>\n<details>
            <summary><code><strong>CLICK HERE:</strong> Example</code></summary> <br/>\n\n```yaml\n-
            time: \"08:00\"\n  comfort: \"20\"\n  calibration: \"off\"\n- time: \"16:00\"\n
            \ eco: \"19\"\n  calibration: \"on\"\n- time: \"20:00\"\n  days: ['Sat','Sun']\n
            \ scheduler: 'Holidays'\n  comfort: \"24\"\n  eco: \"17\"\n```\n</details>\n"
          selector:
            object: {}
          default: '[]'
    mode_section:
      name: Force Comfort/Eco Mode
      icon: mdi:fire
      collapsed: true
      input:
        input_mode_party:
          name: "\U0001F388 Party mode"
          description: '`optional`


            If on, all settings are ignored and heating takes place. You can define
            multiple [timers](https://www.home-assistant.io/integrations/timer/) or
            boolean entities. If you put a number at the end of the friendly name
            like *Party Timer 20* this number will be taken as the desired comfort
            temperature for this [timer](https://www.home-assistant.io/integrations/timer/).


            Create your timer [here](https://my.home-assistant.io/redirect/helpers/).

            '
          default: []
          selector:
            entity:
              filter:
              - domain:
                - input_boolean
                - binary_sensor
                - timer
              multiple: true
        input_force_max_temperature:
          name: "\U0001F975 Force Max Temperature"
          description: '`optional`


            Set the maximum temperature of all [thermostats](https://www.home-assistant.io/integrations/climate/)
            regardless of any other settings.


            **HINT:** Implemented by developer for maintenance reasons. Create your
            helper [here](https://my.home-assistant.io/redirect/helpers/).

            '
          default: []
          selector:
            entity:
              filter:
              - domain:
                - input_boolean
                - binary_sensor
              multiple: false
        input_force_eco_temperature:
          name: "\U0001F331 Force Eco Temperature"
          description: '`optional`


            If enabled *eco* temperature will be forced.

            '
          default: []
          selector:
            entity:
              filter:
              - domain:
                - input_boolean
                - binary_sensor
              multiple: false
        input_party_legacy_restore:
          name: "\U0001F504 Legacy Restore"
          description: "`party` \n\nEnable this if the temperatures after airing (closing
            windows) or party won't restore properly\n"
          default: false
          selector:
            boolean: {}
    temperature_tweak_section:
      name: Temperature Tweaks
      icon: mdi:knob
      collapsed: true
      input:
        input_off_instead_of_eco:
          name: "\U0001F6D1 Off Instead Of Eco"
          description: '`optional` `temperature tweak`


            Turn off your [thermostats](https://www.home-assistant.io/integrations/climate/)
            instead of lower the target temperature to eco temperature.

            '
          default: false
          selector:
            boolean: {}
        input_min_instead_of_off:
          name: ⬇️ Min Instead Of Off
          description: '`optional` `temperature tweak`


            Lower the temperature instead of turning them *OFF*, e.g. during airing.

            '
          default: false
          selector:
            boolean: {}
        input_fahrenheit:
          name: "\U0001F1EB Fahrenheit"
          description: '`optional` `temperature tweak`


            Enable this if your unit of measurement is Fahrenheit (untested).

            '
          default: false
          selector:
            boolean: {}
        input_reset_temperature:
          name: ↩️ Reset Temperature
          description: '`optional` `temperature tweak`


            Reset your temperature entities to the values of the static temperatures
            after [schedule](https://www.home-assistant.io/integrations/schedule/),
            [proximity](https://www.home-assistant.io/integrations/proximity/), [people](https://www.home-assistant.io/integrations/person/),
            presence ends. The comfort entity is reset when eco takes place and vice
            versa.

            '
          default: false
          selector:
            boolean: {}
        input_off_if_above_room_temperature:
          name: ↕️ Off If Above/Below Room Temperature
          description: '

            Turns your [climate](https://www.home-assistant.io/integrations/climate/)
            entity *off* if the target temperature is below(cooling) / above(heating)
            the room temperature.

            '
          default: false
          selector:
            boolean: {}
        input_off_if_nobody_home:
          name: "\U0001F3E0\U0001F6B6‍➡️ Off If Nobody Home"
          description: '

            Turns your [climate](https://www.home-assistant.io/integrations/climate/)
            entity *off* if persons are set and nobody is home.

            '
          default: false
          selector:
            boolean: {}
        input_physical_change:
          name: "\U0001F9EA Physical Temperature Change / Sync (experimental)"
          description: "`optional` `temperature tweak`\n\nEnable this if your want
            to adjust the temperature using your thermostat or thermostat card. Make
            sure aggressive mode and generic calibration is disabled for this feature.
            (experimental). You also need to set entities for eco and comfort temperature
            for the moment. \n"
          default: false
          selector:
            boolean: {}
    person_section:
      name: Persons
      icon: mdi:account-multiple
      collapsed: true
      input:
        input_persons:
          name: "\U0001F465 Persons"
          description: '`person` `optional`


            You can specify [persons](https://www.home-assistant.io/integrations/person/)
            to make your heating plan more dynamic. If you do not use [schedulers](https://www.home-assistant.io/integrations/schedule/)
            or presence sensors, heating is activated as soon as someone is at home.<br/>
            With [schedulers](https://www.home-assistant.io/integrations/schedule/)
            or presence sensors, these are only active when someone is at home.

            '
          default: []
          selector:
            entity:
              filter:
              - domain:
                - person
              multiple: true
        input_people_entering_home_duration:
          name: "\U0001F3E0 Enter Home Duration"
          description: '`person`


            Duration for which someone must be at home for heating to be activated.

            '
          default:
            hours: 0
            minutes: 0
            seconds: 2
          selector:
            duration: {}
        input_people_leaving_home_duration:
          name: "\U0001F4A8 Leaving Home Duration"
          description: '`person`


            Duration for which someone must be out of the house for heating to be
            deactivated.

            '
          default:
            hours: 0
            minutes: 0
            seconds: 2
          selector:
            duration: {}
        input_mode_guest:
          name: "\U0001F91D Guest Mode"
          description: "`person` `optional`\n\n\nIf an entity is specified here, it
            is treated like a [person](https://www.home-assistant.io/integrations/person/).
            It's usefull when you're leaving your guests alone in your home and you
            are not using presence detection.\n\n  * entity defined -> [person](https://www.home-assistant.io/integrations/person/)
            defined\n  * enitity is *on* -> simulates [person](https://www.home-assistant.io/integrations/person/)
            is home\n  * enitity is *off* -> simulates [person](https://www.home-assistant.io/integrations/person/)
            is away\n"
          default:
          selector:
            entity:
              filter:
              - domain:
                - input_boolean
                - binary_sensor
                - timer
              multiple: false
    scheduling_section:
      name: Scheduling
      icon: mdi:clock-outline
      collapsed: true
      input:
        input_schedulers:
          name: ⏲️ Schedules
          description: '`schedules` `optional`


            A [schedule](https://www.home-assistant.io/integrations/schedule/) specifies
            when heating to comfort temperature should take place. You can create
            it in the helper section of Home Assistant.<br/> If you have also specified
            [people](https://www.home-assistant.io/integrations/person/), someone
            must also be at home for heating. This is the same behaviour with a [proximity](https://www.home-assistant.io/integrations/proximity/)
            entity.<br/> You can create as many [schedules](https://www.home-assistant.io/integrations/schedule/)
            as you like. Make sure the names are clear.

            '
          default: []
          selector:
            entity:
              filter:
              - domain:
                - schedule
              multiple: true
        input_scheduler_selector:
          name: "☝\U0001F3FB Scheduler Selector"
          description: "`schedule` `optional`\n\nDefine an entity to choose from your
            schedules. If you use one schedule only you can ignore this. If you use
            more than one schedule you have multiple possibilities to setup your selection.<br/>\n<details>
            <summary><code><strong>CLICK HERE:</strong> More information</code></summary>
            <br/>\n\n\n* toggle [input_boolean](https://www.home-assistant.io/integrations/input_boolean/)
            or [binary_sensor](https://www.home-assistant.io/integrations/binary_sensor/):
            If *off* the first defined [schedule](https://www.home-assistant.io/integrations/schedule/)
            is enabled. If *on* the second [schedule](https://www.home-assistant.io/integrations/schedule/)
            is active. More than two [schedules](https://www.home-assistant.io/integrations/schedule/)
            cannot be selected with binary inputs.\n* text [input text](https://www.home-assistant.io/integrations/input_text/),
            drop down [input text](https://www.home-assistant.io/integrations/input_select/)
            or [sensor](https://www.home-assistant.io/integrations/sensor/):\n  *
            The value has to match the friendly name of the selected [schedule](https://www.home-assistant.io/integrations/schedule/)
            at least partially. Example: If you provide three [schedules](https://www.home-assistant.io/integrations/schedule/)
            called *work*, *holiday/sick*, *guest* you can select the holiday [schedule](https://www.home-assistant.io/integrations/schedule/)
            while setting the selection entity to *sick*, *holiday* or *holiday/sick*.
            This option is case insensitive.\n  * You also can go with numbers: if
            you want to choose the first [schedule](https://www.home-assistant.io/integrations/schedule/)
            the selector entity must return the number *1*. For the 2nd number *2*
            and so on.\n\n</details>\n"
          default:
          selector:
            entity:
              filter:
              - domain:
                - input_boolean
                - binary_sensor
                - input_text
                - input_number
                - input_select
              multiple: false
    presence_section:
      name: Presence Detection
      icon: mdi:location-enter
      collapsed: true
      input:
        input_presence_sensor:
          name: "\U0001F6B6 Presence Sensor / On/Off-Entity"
          description: '`presence detection` `optional`


            If you specify a presence sensor, heating will take place if it detects
            presence.<br/> If you have specified [persons](https://www.home-assistant.io/integrations/person/),
            at least one must also be at home. You also can select an [input boolean](https://www.home-assistant.io/integrations/input_boolean/)
            entity to realise a simple On/Off-Logic.

            '
          default:
          selector:
            entity:
              filter:
              - domain:
                - binary_sensor
                - input_boolean
              multiple: false
        input_scheduler_presence:
          name: ⏲️ Presence Sensor Scheduler
          description: '`presence detection` `optional`


            The presence [schedule](https://www.home-assistant.io/integrations/schedule/)
            specifies exactly when the presence sensor should be used during the day.

            '
          default:
          selector:
            entity:
              filter:
              - domain:
                - schedule
              multiple: false
        input_presence_reaction_on_time:
          name: ⏳ Presence Reaction On Time
          description: '`presence detection`


            Specify the duration for which the presence sensor must detect any presence
            so that the comfort temperature is set.

            '
          default:
            hours: 0
            minutes: 5
            seconds: 0
          selector:
            duration: {}
        input_presence_reaction_off_time:
          name: ⌛ Presence Reaction Off Time
          description: '`presence detection`


            Specify the duration for which the presence sensor must not detect any
            presence so that the eco temperature is set.

            '
          default:
            hours: 0
            minutes: 5
            seconds: 0
          selector:
            duration: {}
    proximity_section:
      name: Proximity
      icon: mdi:leak
      collapsed: true
      input:
        input_proximity:
          name: ↔️ Proximity
          description: '`proximity` `optional`


            You can preheat your rooms with help of home assistant''s [proximity integration](https://www.home-assistant.io/integrations/proximity/).<br/>
            Just select your proxmity zone and take your adjustments to distance and
            duration.<br/> If you''re in range of your distance and towards to your
            home heating kicks in.<br/>

            **Note**: The proximity entity is handles like a person. Comfort heating
            takes place when coming or beeing home. Combinations with [schedules](https://www.home-assistant.io/integrations/schedule/)
            are also possible.

            '
          default:
          selector:
            device:
              filter:
              - integration: proximity
              multiple: false
        input_proximity_duration:
          name: ⏰ Proximity Duration
          description: '`proximity`


            Duration for which someone must be on way home before heating occurs.

            '
          default:
            hours: 0
            minutes: 2
            seconds: 0
          selector:
            duration: {}
        input_proximity_distance:
          name: ↔️ Proximity Distance
          description: '`proximity`


            The distance when [proximity](https://www.home-assistant.io/integrations/proximity/)
            sensor gets impact for this automation. Hint: Unit depends on the setup
            of your integration.

            '
          default: 500
          selector:
            number:
              min: 0.0
              max: 999999999.0
              step: 1.0
              mode: box
    away_section:
      name: Away Mode
      icon: mdi:walk
      collapsed: true
      input:
        input_away_offset:
          name: "\U0001F3C3 Away Temperature Offset"
          description: '`scheduler` `persons` `presence` `away mode`


            First: This feature only works for [schedule](https://www.home-assistant.io/integrations/schedule/)
            and/or presence based heating combined with [persons](https://www.home-assistant.io/integrations/person/).
            You can define an offset for your comfort temperature that will be subtracted
            (heating) from or added (cooling) to your comfort temperature.

            If you enable this option for [schedules](https://www.home-assistant.io/integrations/schedule/)
            the away offset will be substracted from the comfort temperature if your
            schedule is *on* but nobody is at home. For presence detection this is
            the case if you are at home but no presence is detected. For presence
            detection you can also ignoring [persons](https://www.home-assistant.io/integrations/person/).
            So the away temperature is set when no presence is detected but the presence
            [schedule](https://www.home-assistant.io/integrations/schedule/) is *on*.

            '
          default: 0
          selector:
            number:
              min: 0.0
              max: 10.0
              step: 0.5
              mode: slider
              unit_of_measurement: °C / °F
        input_away_scheduler_mode:
          name: ⏲️ Scheduler Away Mode
          description: '`scheduler` `away mode`


            Enable/Disable the Away Offset for [schedules](https://www.home-assistant.io/integrations/schedule/)
            based heating/cooling.

            '
          default: false
          selector:
            boolean: {}
        input_away_presence_mode:
          name: "\U0001F6B6 Presence Away Mode"
          description: '`presence` `away mode`


            Enable/Disable the Away Offset for presence based heating/cooling.

            '
          default: false
          selector:
            boolean: {}
        input_away_presence_ignor_people:
          name: "\U0001F6B6 Ignore People For Presence Away Mode"
          description: '`presence` `away mode`


            If you want to make away happen if your presence [schedule](https://www.home-assistant.io/integrations/schedule/)
            is on but no motion is detected regardless if somebody is at home enable
            this option.

            '
          default: false
          selector:
            boolean: {}
    window_section:
      name: Window & Door Detection
      icon: mdi:door
      collapsed: true
      input:
        input_windows:
          name: "\U0001FA9F Windows & Doors"
          description: '`airing` `optional`


            If open during airing your [thermostats](https://www.home-assistant.io/integrations/climate/)
            will be set to *off* at least to their minimum temperature  if they don''t
            support hvac mode *OFF* except you set a custom window open temperature.

            '
          default: []
          selector:
            entity:
              filter:
              - domain:
                - binary_sensor
                - sensor
              multiple: true
        input_windows_reaction_time_open:
          name: ⏳ Window & Door Reaction Time Open
          description: '`airing`


            Duration for which a window or door must be open for the [thermostats](https://www.home-assistant.io/integrations/climate/)
            to close.

            '
          default:
            hours: 0
            minutes: 0
            seconds: 30
          selector:
            duration: {}
        input_windows_reaction_time_close:
          name: ⌛ Window & Door Reaction Time Close
          description: "`airing`  \n\nDuration for which a window or door must be
            closed for the [thermostats](https://www.home-assistant.io/integrations/climate/)
            to open.\n"
          default:
            hours: 0
            minutes: 0
            seconds: 30
          selector:
            duration: {}
        input_window_open_temperature:
          name: Window Open Temperature
          description: "`airing` \n\nIf 0° your thermostat turns *off* or if not supported
            it turns to the minimum temperature of your thermostat.\n"
          default: 0
          selector:
            number:
              min: 0.0
              max: 15.0
              step: 1.0
              mode: slider
              unit_of_measurement: °C / °F
        input_window_legacy_restore:
          name: "\U0001F3DA️ Legacy Restore"
          description: "`airing` \n\nEnable this if the temperatures after airing
            (closing windows) won't restore properly.\n"
          default: false
          selector:
            boolean: {}
    calibration_section:
      name: Calibration
      icon: mdi:compass
      description: ''
      collapsed: true
      input:
        input_calibration_timeout:
          name: ⏳ Calibration Timeout
          description: '`calibration`


            Define a timeout if you want to decrease the amount of calibration calls
            if temperature changes too much. At least the temperature of the external
            sensor or [thermostat](https://www.home-assistant.io/integrations/climate/)
            must stay for that duration before calibration gets triggered.

            **HINT:** A minimum timeout of 2s is recommended.

            '
          default:
            hours: 0
            minutes: 1
            seconds: 0
          selector:
            duration: {}
        input_calibration_delta:
          name: ↔️ Calibration Delta
          description: '`calibration`


            If the difference between the [thermostat](https://www.home-assistant.io/integrations/climate/)
            temperature and the external sensor temperature is greater or less than
            the calibration delta the [thermostat](https://www.home-assistant.io/integrations/climate/)
            calibration will be triggered.<br/> The lower the delta the often calibration
            gets triggered.

            '
          default: 0.5
          selector:
            number:
              min: 0.0
              max: 5.0
              step: 0.1
              mode: slider
              unit_of_measurement: °C / °F
        input_calibration_key_word:
          name: "\U0001F5DD️ Calibration Entity Key Word"
          description: '`calibration`


            Keyword for finding the calibration entity. This word must be part of
            the entity id.  As a rule, the entities with the word *offset*, *calibration*
            or *external* are marked by the integrations. Just have a look into your
            device overview, select your thermostat and check the naming of the *entity_ids*
            for the calibration.

            '
          default: calibration
          selector:
            text: {}
        input_calibration_step_size:
          name: "\U0001F9B6 Step Size"
          description: '`calibration`


            Usually the step size is determined automatically. You can overwrite the
            step size by selecting another option if you know your thermostat handles
            the calibration not like the entities are exposed.

            '
          default: auto
          selector:
            select:
              mode: dropdown
              options:
              - label: Auto
                value: auto
              - label: '0.1'
                value: '0.1'
              - label: '0.5'
                value: '0.5'
              - label: Full Values
                value: full
              multiple: false
              custom_value: false
              sort: false
        input_calibration_generic:
          name: "\U0001F9ED Generic Calibration"
          description: '`generic` `calibration`


            Adds the difference between room and [thermostat](https://www.home-assistant.io/integrations/climate/)
            temperature to the target temperature. This is useful if your thermostat
            integration doesn''t provide a special entity for calibration. Keep in
            mind the set temperatures for your thermostats will differ to the target
            temperature.

            '
          default: false
          selector:
            boolean: {}
        input_generic_calibration_offset:
          name: ↕️ Generic Calibration Offset
          description: '`generic` `calibration`


            If the temperature difference between the thermostat and the temperature
            sensor is very high,  the offset, i.e. the correction temperature, can
            be limited to this value.

            <details> <summary><code><strong>CLICK HERE:</strong> Example</code></summary>
            Generic Calibration Offset = 5°</br> Thermostat Temperature = 28°</br>
            Room Temperature = 18°</br> </br> Difference = Thermostat Temperature
            - Room Temperature = 10°</br> Difference > Generic Calibration Offset
            -> Corrected Difference = 5°</br> New Target Temperature = Thermostat
            Temperature + Corrected Difference = 33° </details>

            '
          default: 5
          selector:
            number:
              min: 0.0
              max: 20.0
              step: 1.0
              mode: slider
              unit_of_measurement: °C / °F
    aggressive_mode_section:
      name: Aggressive Mode
      icon: mdi:emoticon-angry
      collapsed: true
      input:
        input_aggressive_mode_range:
          name: "\U0001F621 Aggressive Range"
          description: "`aggressive mode` `tweak`\n\nActivate this option if your
            [thermostats](https://www.home-assistant.io/integrations/climate/) react
            slowly or only start to react at a large temperature difference  between
            actual and set temperature. Define a range when your real target temperature
            shall be set. \n<details> <summary><code><strong>CLICK HERE:</strong>
            More information</code></summary> <br/>\nE.g. you target temperature is
            20°C and your room temperature is 19.5°C. If your range is set to 0.5°C
            the real target temperature (20°C) will be set when room temperature is
            between 19.5°C and 20.5°C. If the room temperature is above or lower than
            range, it gets some offset in order to force your [thermostat](https://www.home-assistant.io/integrations/climate/)
            to react.  (see Aggressive Mode - Offset)\n</details>\n"
          default: 0
          selector:
            number:
              min: 0.0
              max: 5.0
              step: 0.1
              mode: slider
              unit_of_measurement: °C / °F
        input_aggressive_mode_offset:
          name: ↕ Aggressive Offset
          description: '`aggressive mode` `tweak`


            Here you can define the offset that will be added to your target temperature
            if the room temperature is not in range of your target temperature. If
            your room temperature is not in the defined range, e.g. 19.5°C - 20.5°C
            this offset will be added to your target temperature. If range is 0, then
            offset is always added.

            '
          default: 0
          selector:
            number:
              min: 0.0
              max: 5.0
              step: 0.5
              mode: slider
              unit_of_measurement: °C / °F
        input_aggressive_mode_calibration:
          name: "\U0001F321️ Aggressive Calibration"
          description: "`aggressive mode` `tweak` `experimental` \nIf you'd setup
            an temperature sensor and your thermostats allow calibration, you can
            enable this feature. If enabled the aggressive offset will be add  to
            the calibration value and not the target temperature.\n*Note*: This feature
            is marked as experimental since not every calibration method could be
            tested. If you notice any problems simple open an issue or  post a message
            in the [AHC-Thread](https://community.home-assistant.io/t/advanced-heating-control/469873).
            \ Enable this only if native calibration does NOT work when using generic
            calibration.\n"
          default: false
          selector:
            boolean: {}
    frostprotection_section:
      name: Frost Protection
      icon: mdi:snowflake
      collapsed: true
      input:
        input_frost_protection_temp:
          name: ❄️ Frost Protection Temperature
          description: '`frost protection`


            You can set the frost protection temperature here.

            '
          default: 5
          selector:
            number:
              min: 5.0
              max: 62.0
              step: 0.5
              mode: box
              unit_of_measurement: °C / °F
        input_frost_protection_duration:
          name: ❄️ Frost Protection Fallback Duration
          description: '`frost protection`


            If the defined [persons](https://www.home-assistant.io/integrations/person/)
            are not at home for a longer period of time or the presence sensor has
            no longer detected any presence, the frost protection temperature can
            be lowered after a this duration. Note: If set to zero frost protection
            temperature never will be set.

            '
          default:
            days: 0
            hours: 0
            minutes: 0
            seconds: 0
          selector:
            duration:
              enable_day: true
    liming_protection_section:
      name: Liming Protection
      icon: mdi:pipe-valve
      collapsed: true
      input:
        input_liming_protection:
          name: "\U0001F39A️ Liming Protection"
          description: '`liming protection`


            Most smart thermostats come with that feature out of the box.  If your
            thermostat doesn''t support this or you''re using the generic thermostat
            integration this feature is maybe handy for you in order to prevent your
            valve against limescale.  The automation will set the thermostat to its
            max and open the valve for one minute.

            '
          default: false
          selector:
            boolean: {}
        input_liming_protection_day:
          name: "\U0001F5D3️ Day"
          description: '`liming protection`


            Select the day of the week for the execution.

            '
          default: Mon
          selector:
            select:
              options:
              - label: Monday
                value: Mon
              - label: Tuesday
                value: Tue
              - label: Wednesday
                value: Wed
              - label: Thursday
                value: Thu
              - label: Friday
                value: Fri
              - label: Saturday
                value: Sat
              - label: Sunday
                value: Sun
              multiple: false
              custom_value: false
              sort: false
        input_liming_protection_time:
          name: "\U0001F556 Time"
          description: '`liming protection`


            Select the time for the execution.

            '
          default: '12:00:00'
          selector:
            time: {}
        input_liming_in_winter:
          name: "\U0001F328️ Liming In Winter / Liming If Automation is Disabled"
          description: '`liming protection`


            Enable this if you want liming protection even if the automation is active.

            '
          default: false
          selector:
            boolean: {}
    toggle_section:
      name: On/Off Automation Options
      icon: mdi:light-switch
      collapsed: true
      input:
        input_mode_winter:
          name: ⛄ Winter Mode / Automation Toggle
          description: "`activation` `optional`\n\nIf *on* the automation is active.
            If *off* your valves will set to *off* and the automation is going to
            sleep. You can set this up with:\n\n  * [input boolean](https://www.home-assistant.io/integrations/input_boolean/)\n
            \ * [binary sensor](https://www.home-assistant.io/integrations/binary_sensor/)\n\n\nCreate
            your helper [here](https://my.home-assistant.io/redirect/helpers/).\n"
          default:
          selector:
            entity:
              filter:
              - domain:
                - input_boolean
                - binary_sensor
              multiple: false
        input_invert_winter_mode_value:
          name: "\U0001F504 Invert Winter Mode Value"
          description: "`activation`\n\nIf enabled the the value of the binary winter
            mode entity will be inverted:\n\n  * off -> activates the automation\n
            \ * on -> disables the automation\n"
          default: false
          selector:
            boolean: {}
        input_mode_outside_temperature:
          name: "\U0001F324️ Outside Temperature Sensor"
          description: "`activation` `optional`\n\nYou can control the switching on
            and off of your thermostats via the outside temperature.  To do this,
            select a temperature sensor or a weather entity and adjust the threshold
            below.\n\n  * [weather entity](https://www.home-assistant.io/integrations/weather/)\n
            \ * [temperature sensor entity](https://www.home-assistant.io/integrations/sensor/)\n"
          default:
          selector:
            entity:
              filter:
              - domain:
                - weather
              - domain:
                - sensor
                device_class:
                - temperature
              multiple: false
        input_mode_outside_temperature_threshold:
          name: "\U0001F39A️ Outside Temperature Threshold"
          description: '`activation`


            If you''d select a temperature [sensor](https://www.home-assistant.io/integrations/sensor/)
            or a [weather entity](https://www.home-assistant.io/integrations/weather/)  for
            controlling heating you can adjust the temperature threshold here. If
            the outside temperature falls below the threshold value, heating is activated.

            '
          default: 15
          selector:
            number:
              min: 5.0
              max: 68.0
              step: 0.5
              mode: box
              unit_of_measurement: °C / °F
        input_mode_room_temperature:
          name: "\U0001F518 Enable Room Temperature Threshold"
          description: '`activation` `optional`


            If you enable this option the value of the defined room temperature sensor
            and the value of the outside temperautre must be below / above its threshold.
            That makes sense if you go with an A/C and the room is still heated up
            but it has already cooled down outside.


            **Not recommendend for heating**

            '
          default: false
          selector:
            boolean: {}
        input_mode_room_temperature_threshold:
          name: "\U0001F39A️ Room Temperature Threshold"
          description: '`activation`


            Threshold for your room temperature sensor.

            '
          default: 18
          selector:
            number:
              min: 5.0
              max: 68.0
              step: 0.5
              mode: box
              unit_of_measurement: °C / °F
    valve_positioning_section:
      name: Dynamic Valve Positioning
      icon: mdi:valve
      collapsed: true
      input:
        input_valve_positioning_mode:
          name: "\U0001F9B6 Valve Positioning Mode"
          description: "`valve positioning`\n\n\n If your thermostat supports valve
            positioning you can enable this here. Everytime the autmation gets triggered
            the code checks if there is an adjustment needed.\n\n\n\U0001F4C8 **regular**:
            means linear. The valve will open close proportional to the difference
            of the target and room temperature.\n\n\U0001F60A **optimistic**: The
            valve opening is reduced earlier, as it is assumed that the radiator still
            has enough residual heat to heat the room.\n\n\U0001F641 **pessimistic**:
            The valve opening is initially left relatively open and only closes rapidly
            when the target temperature is almost reached.\n"
          default: 'off'
          selector:
            select:
              mode: dropdown
              options:
              - label: 'off'
                value: 'off'
              - label: regular
                value: regular
              - label: optimistic
                value: optimistic
              - label: pessimistic
                value: pessimistic
              multiple: false
              custom_value: false
              sort: false
        input_fully_open_difference:
          name: ↔️ Positioning Temperature Difference
          description: "`valve positioning`\n\nThe difference between target and set
            temperature when dynamic valve positioninig should happen.\n\n<details>
            <summary><code><strong>CLICK HERE:</strong> Example</code></summary> <br/>\n\n>
            Positioning Temperature Difference: 1°\n> Target Temperature: 21°<br/>\n\n>
            Positioning takes place in a range between 21° and 20° (21°-1°)\n\n> If
            the local temperature is 21.5° the valve positioning is calculated and
            set.\n> If the local temperture is below this range the valve is fully
            open.\n</details>\n  \n"
          default: 1
          selector:
            number:
              min: 0.5
              max: 20.0
              step: 0.5
              mode: box
              unit_of_measurement: °C / °F
        input_valve_positioning_step_size:
          name: "\U0001F9B6 Valve Positioning Step Size"
          description: '`valve positioning`


            The step size of for opening/closing the valve.

            '
          default: '10'
          selector:
            select:
              mode: dropdown
              options:
              - label: 5%
                value: '5'
              - label: 10%
                value: '10'
              - label: 20%
                value: '20'
              multiple: false
              custom_value: false
              sort: false
        input_valve_positioning_timeout:
          name: ⏱️ Valve Positioning Timeout
          description: '`valve positioning`


            Timeout that must lie between two adjustments before the second is executed.

            '
          default:
            hours: 0
            minutes: 20
            seconds: 0
          selector:
            duration: {}
        input_valve_opening_keyword:
          name: "\U0001F5DD️ Positioning Entity Keyword"
          description: '`valve positioning`


            The key word for selecting the opening entity of your thermostats.

            '
          default: valve_opening_degree
          selector:
            text: {}
    tweak_section:
      name: Custom Settings
      icon: mdi:cog-box
      collapsed: true
      input:
        input_action_call_delay:
          name: ⚙️ Action Call Delay
          description: '`tweak`


            Some [thermostats](https://www.home-assistant.io/integrations/climate/)
            have problems with setting mode and temperature. You can try to increase
            the delay between the action calls. This could fix your problems.

            '
          default:
            hours: 0
            minutes: 0
            seconds: 2
          selector:
            duration: {}
        input_startup_delay:
          name: ⏲ Startup Delay
          description: "`tweak`  \n\nIf your AHC automation is triggered directly
            after a Home Assistant restart, but the required integrations have not
            yet been loaded or certain sensors  have not yet been initialized, you
            can set an automation delay here.\n*Note:* Make sure that you have set
            up the uptime integration for this purpose.\n"
          default:
            hours: 0
            minutes: 0
            seconds: 0
          selector:
            duration: {}
        input_custom_action:
          name: "\U0001F3AC Custom Action"
          description: '`optional`


            This custom action gets executed with every temperature / mode change
            except calibration. If you want to control other devices just check states
            before doing an action call. Use the variable *is_heating* in your conditions.
            *True* means heating is active.

            '
          default:
          selector:
            action: {}
        input_custom_condition:
          name: ☑️ Temperature Change Custom Condition
          description: '`optional`


            Define a custom condition that prevents / allows temperature changes to
            your thermostats. This has no impact to the rest of logic like calibration.

            '
          default:
          selector:
            condition: {}
        input_custom_condition_calibration:
          name: ☑️ Calibration Custom Condition
          description: '`optional`


            Define a custom condition that prevents / allows calibration.

            '
          default:
          selector:
            condition: {}
        input_log_level:
          name: ✍️ Log Level
          description: ''
          default: debug
          selector:
            select:
              mode: dropdown
              options:
              - info
              - warning
              - error
              - debug
              multiple: false
              custom_value: false
              sort: false
trigger_variables:
  input_trvs: !input input_trvs
  input_temperature_sensor: !input input_temperature_sensor
  is_temperature_sensor_defined: '{{ input_temperature_sensor != [] }}'
  input_persons: !input input_persons
  input_mode_guest: !input input_mode_guest
  input_people_entering_home_duration: !input input_people_entering_home_duration
  input_people_leaving_home_duration: !input input_people_leaving_home_duration
  input_person_count: '{{ input_persons | count }}'
  is_person_defined: '{{ input_person_count > 0 }}'
  is_guest_mode_defined: '{{ input_mode_guest != none }}'
  input_schedulers: !input input_schedulers
  input_scheduler_selector: !input input_scheduler_selector
  input_scheduler_presence: !input input_scheduler_presence
  is_scheduler_presence_defined: '{{ input_scheduler_presence != none }}'
  input_temperature_comfort: !input input_temperature_comfort
  input_temperature_eco: !input input_temperature_eco
  input_hvac_mode: !input input_hvac_mode
  factor: '{{ iif(input_hvac_mode == ''cool'', -1, 1) | int }}'
  is_heat_only_if_below_real_temp: !input input_off_if_above_room_temperature
  input_mode_winter: !input input_mode_winter
  input_mode_outside_temperature: !input input_mode_outside_temperature
  input_mode_outside_temperature_threshold: !input input_mode_outside_temperature_threshold
  input_mode_room_temperature_threshold: !input input_mode_room_temperature_threshold
  input_mode_room_temperature: !input input_mode_room_temperature
  input_invert_winter_mode_value: !input input_invert_winter_mode_value
  input_mode_party: !input input_mode_party
  input_adjustments: !input input_adjustments
  input_calibration_timeout: !input input_calibration_timeout
  input_windows: !input input_windows
  input_presence_sensor: !input input_presence_sensor
  is_presence_sensor_defined: '{{ input_presence_sensor != none }}'
  input_presence_reaction_on_time: !input input_presence_reaction_on_time
  input_presence_reaction_off_time: !input input_presence_reaction_off_time
  input_proximity: !input input_proximity
  input_proximity_duration: !input input_proximity_duration
  input_proximity_distance: !input input_proximity_distance
  input_frost_protection_duration: !input input_frost_protection_duration
  input_liming_protection: !input input_liming_protection
  input_liming_protection_day: !input input_liming_protection_day
  input_liming_protection_time: !input input_liming_protection_time
  input_liming_in_winter: !input input_liming_in_winter
trigger:
- trigger: homeassistant
  event: start
  id: temperature_change_hastart
- trigger: event
  event_type: automation_reloaded
  id: temperature_change_reload
- trigger: event
  event_type: ahc_delay_event
  id: delayed_call_temperature_change
  event_data:
    automation: '{{ this.entity_id }}'
- trigger: state
  entity_id: !input input_trvs
  from:
  - unknown
  - unavailable
  for:
    seconds: 5
  id: temperature_change_available
- trigger: state
  entity_id: !input input_trvs
  attribute: temperature
  for:
    seconds: 5
  id: temperature_change_valve_target
- trigger: state
  entity_id: !input input_temperature_eco
  for: !input input_action_call_delay
  id: temperature_change_eco
- trigger: state
  entity_id: !input input_temperature_comfort
  for: !input input_action_call_delay
  id: temperature_change_comfort
- trigger: template
  value_template: "{{ input_persons  | expand \n                  | selectattr('state',
    'eq', 'home') \n                  | list \n                  | count > 0 \n                  \n
    \ or (is_guest_mode_defined and states(input_mode_guest) in ['on','active'] )
    }}\n"
  id: temperature_change_person_on
  for: !input input_people_entering_home_duration
- trigger: template
  value_template: "{{ input_persons  | expand \n                  | selectattr('state',
    'eq', 'home') \n                  | list \n                  | count == 0 \n  \n
    \ and (not is_guest_mode_defined or (is_guest_mode_defined and states(input_mode_guest)
    not in ['on','active'])) }}\n"
  id: temperature_change_person_off
  for: !input input_people_leaving_home_duration
- trigger: template
  id: temperature_change_scheduler_on
  value_template: "{% set selected_scheduler = none %} {% set schedules_count = input_schedulers
    | count %}\n{% if schedules_count == 0 %}\n  {% set selected_scheduler = none
    %}\n{% elif schedules_count == 1 or input_scheduler_selector == none %}\n  {%
    set selected_scheduler = input_schedulers | first %}\n{% elif schedules_count
    > 1 %}\n  {% set selector_value = states(input_scheduler_selector) %}\n\n  {%
    if is_number(selector_value) %}\n    {% set selector_value = iif(selector_value
    | int > schedules_count, schedules_count, selector_value) %}\n    {% set selector_value
    = iif(selector_value | int <= 0, 1, selector_value) %}\n    {% set selected_scheduler
    = input_schedulers[selector_value | int - 1] %}\n  {% elif selector_value in ['on','off']
    %}\n    {% set selected_scheduler = iif(selector_value == 'off', input_schedulers[0],
    input_schedulers[1]) %}\n  {% else %}\n    {% set selected_scheduler = input_schedulers
    | expand | selectattr('attributes.friendly_name', 'eq', selector_value) | map(attribute='entity_id')
    | first | default(none) %}\n    {% if (selected_scheduler == none) %}\n      {%
    set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name',
    'search', '(?i)' + selector_value) | map(attribute='entity_id') | first | default(none)
    %}\n    {% endif %}\n  {% endif %}\n{% endif %}\n{% if selected_scheduler == none
    %}\n  {{ false }}\n{% else %}\n  {{ is_state(selected_scheduler, 'on') }}\n{%
    endif %}\n"
- trigger: template
  id: temperature_change_scheduler_off
  value_template: "{% set selected_scheduler = none %} {% set schedules_count = input_schedulers
    | count %}\n{% if schedules_count == 0 %}\n  {% set selected_scheduler = none
    %}\n{% elif schedules_count == 1 or input_scheduler_selector == none %}\n  {%
    set selected_scheduler = input_schedulers | first %}\n{% elif schedules_count
    > 1 %}\n  {% set selector_value = states(input_scheduler_selector) %}\n\n  {%
    if is_number(selector_value) %}\n    {% set selector_value = iif(selector_value
    | int > schedules_count, schedules_count, selector_value) %}\n    {% set selector_value
    = iif(selector_value | int <= 0, 1, selector_value) %}\n    {% set selected_scheduler
    = input_schedulers[selector_value | int - 1] %}\n  {% elif selector_value in ['on','off']
    %}\n    {% set selected_scheduler = iif(selector_value == 'off', input_schedulers[0],
    input_schedulers[1]) %}\n  {% else %}\n    {% set selected_scheduler = input_schedulers
    | expand | selectattr('attributes.friendly_name', 'eq', selector_value) | map(attribute='entity_id')
    | first | default(none) %}\n    {% if (selected_scheduler == none) %}\n      {%
    set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name',
    'search', '(?i)' + selector_value) | map(attribute='entity_id') | first | default(none)
    %}\n    {% endif %}\n  {% endif %}\n{% endif %}\n{% if selected_scheduler == none
    %}\n  {{ false }}\n{% else %}\n  {{ is_state(selected_scheduler, 'off') }}\n{%
    endif %}\n"
- trigger: template
  id: temperature_change_presence_on
  value_template: '{{ input_presence_sensor != none and is_state(input_presence_sensor,
    ''on'') }}'
  for: !input input_presence_reaction_on_time
- trigger: template
  id: temperature_change_presence_off
  value_template: '{{ input_presence_sensor != none and is_state(input_presence_sensor,
    ''off'') }}'
  for: !input input_presence_reaction_off_time
- trigger: template
  id: temperature_change_presence_scheduler_on
  value_template: '{{ input_scheduler_presence != none and is_state(input_scheduler_presence,
    ''on'') }}'
  for: !input input_action_call_delay
- trigger: template
  id: temperature_change_presence_scheduler_off
  value_template: '{{ input_scheduler_presence != none and is_state(input_scheduler_presence,
    ''off'') }}'
  for: !input input_action_call_delay
- trigger: template
  id: temperature_change_person_proximity_on
  value_template: "{% set proximity_entities = device_entities(input_proximity) %}\n{%
    set is_arrived = proximity_entities  \n    | select('is_state','arrived') \n    |
    expand \n    | selectattr('attributes.device_class', 'eq', 'enum')\n    | list
    | count > 0 %}\n\n{% set entities_towards = proximity_entities  \n    | expand
    \n    | selectattr('attributes.device_class', 'eq', 'enum') \n    | map(attribute='entity_id')
    | select('is_state','towards') \n    | map('regex_replace','_(?=[^_]*$)(.*)',
    '')\n    | list %}\n\n{% set distances = proximity_entities  \n  | expand \n  |
    selectattr('attributes.device_class', 'eq', 'distance')\n  | map(attribute='state')\n
    \ | reject('eq', 'unknown')\n  | map('int')\n  | select('<=', input_proximity_distance
    | int)\n  | map('string')\n  | list %}\n\n{% set entities_distances = proximity_entities
    \ \n    | expand \n    | selectattr('attributes.device_class', 'eq', 'distance')\n
    \   | selectattr('state', 'in', distances)\n    | map(attribute='entity_id')\n
    \   | map('regex_replace','_(?=[^_]*$)(.*)', '')\n    | list %}\n\n{% set entites_towards_and_in_distance
    = entities_towards | select('in', entities_distances) | list | count > 0 %}\n{{
    entites_towards_and_in_distance or is_arrived }}\n"
  for: !input input_proximity_duration
- trigger: template
  id: temperature_change_person_proximity_off
  value_template: "{% set proximity_entities = device_entities(input_proximity) %}
    {% set is_arrived = proximity_entities  \n    | select('is_state','arrived') \n
    \   | expand \n    | selectattr('attributes.device_class', 'eq', 'enum') \n    |
    list | count > 0 %}\n\n{% set entities_towards = proximity_entities  \n    | expand
    \n    | selectattr('attributes.device_class', 'eq', 'enum') \n    | map(attribute='entity_id')
    | select('is_state','towards') \n    | map('regex_replace','_(?=[^_]*$)(.*)',
    '')\n    | list %}\n\n{% set distances = proximity_entities  \n  | expand \n  |
    selectattr('attributes.device_class', 'eq', 'distance')\n  | map(attribute='state')\n
    \ | reject('eq', 'unknown')\n  | map('int')\n  | select('<=', input_proximity_distance
    | int)\n  | map('string')\n  | list %}\n\n{% set entities_distances = proximity_entities
    \ \n    | expand \n    | selectattr('attributes.device_class', 'eq', 'distance')\n
    \   | selectattr('state', 'in', distances)\n    | map(attribute='entity_id')\n
    \   | map('regex_replace','_(?=[^_]*$)(.*)', '')\n    | list %}\n\n{% set entites_towards_and_in_distance
    = entities_towards | select('in', entities_distances) | list | count > 0 %}\n{{
    entites_towards_and_in_distance == false and is_arrived == false }}\n"
  for: !input input_proximity_duration
- trigger: template
  value_template: '{{ expand(input_windows) | selectattr(''state'', ''in'', [''on'',''open'',''tilted''])
    | list | count > 0 }}'
  for: !input input_windows_reaction_time_open
  id: temperature_change_window_on
- trigger: template
  value_template: '{{ expand(input_windows) | selectattr(''state'', ''in'', [''on'',''open'',''tilted''])
    | list | count == 0 }}'
  for: !input input_windows_reaction_time_close
  id: temperature_change_window_off
- trigger: template
  id: temperature_change_winter_mode_on
  value_template: "{% if input_mode_winter != none %}\n  {% set activation_state =
    iif(input_invert_winter_mode_value, 'off', 'on') %}\n  {{ is_state(input_mode_winter,
    activation_state) }}\n{% endif %}\n"
  for: !input input_action_call_delay
- trigger: template
  id: temperature_change_winter_mode_off
  value_template: "{% if input_mode_winter != none %}\n  {% set activation_state =
    iif(input_invert_winter_mode_value, 'off', 'on') %}\n  {{ not is_state(input_mode_winter,
    activation_state) }}\n{% endif %}\n"
  for: !input input_action_call_delay
- trigger: template
  id: temperature_change_outside_on
  value_template: "{% if input_mode_outside_temperature == none %}\n  {{ false }}\n{%
    else %}\n  {% set outside_state = false %}\n  {% set use_room_temp = input_mode_room_temperature
    and is_temperature_sensor_defined %}\n  {% set room_state = iif(use_room_temp,
    false, true) %}\n\n  {% set state = states(input_mode_outside_temperature) %}\n
    \ {% set state = iif(is_number(state) == true, state, state_attr(input_mode_outside_temperature,'temperature'))%}\n\n
    \ {% if is_number(state) %}\n    {% set outside_state = (state | float - input_mode_outside_temperature_threshold
    | float) * factor < 0 %}\n  {% endif %}\n\n  {% if use_room_temp %}\n    {% set
    state = states(input_temperature_sensor) %}\n\n    {% if is_number(state) %}\n
    \     {% set room_state = (state | float - input_mode_room_temperature_threshold
    | float) * factor < 0 %}\n    {% endif %}\n  {% endif %}\n\n  {{ room_state and
    outside_state }}\n{% endif %}\n"
  for: !input input_action_call_delay
- trigger: template
  id: temperature_change_outside_off
  value_template: "{% if input_mode_outside_temperature == none %}\n  {{ false }}\n{%
    else %}\n  {% set outside_state = false %}\n  {% set use_room_temp = input_mode_room_temperature
    and is_temperature_sensor_defined %}\n  {% set room_state = iif(use_room_temp,
    false, true) %}\n\n  {% set state = states(input_mode_outside_temperature) %}\n
    \ {% set state = iif(is_number(state) == true, state, state_attr(input_mode_outside_temperature,'temperature'))%}\n\n
    \ {% if is_number(state) %}\n    {% set outside_state = (state | float - input_mode_outside_temperature_threshold
    | float) * factor < 0 %}\n  {% endif %}\n\n  {% if use_room_temp %}\n    {% set
    state = states(input_temperature_sensor) %}\n\n    {% if is_number(state) %}\n
    \     {% set room_state = (state | float - input_mode_room_temperature_threshold
    | float) * factor < 0 %}\n    {% endif %}\n  {% endif %}\n\n  {{ not (room_state
    and outside_state) }}\n{% endif %}\n"
  for: !input input_action_call_delay
- trigger: state
  id: temperature_change_force_max_temperature_on
  entity_id: !input input_force_max_temperature
  for: !input input_action_call_delay
- trigger: state
  id: temperature_change_force_eco_temperature_ds
  entity_id: !input input_force_eco_temperature
  for: !input input_action_call_delay
- trigger: template
  id: temperature_change_party_on
  value_template: '{{ input_mode_party | expand | selectattr(''state'', ''in'', [''active'',''on''])
    | list | count > 0 }}'
  for: !input input_action_call_delay
- trigger: template
  value_template: '{{ input_mode_party | expand | selectattr(''state'', ''in'', [''active'',''on''])
    | list | count == 0 }}'
  id: temperature_change_party_off
  for: !input input_action_call_delay
- trigger: state
  id: calibration_aggressive_mode_above_temp_thermostat_current_temp_change
  entity_id: !input input_trvs
  attribute: current_temperature
  for: !input input_calibration_timeout
- trigger: state
  id: calibration_aggressive_mode_thermostat_temp_change
  entity_id: !input input_trvs
  attribute: temperature
  for:
    seconds: 30
- trigger: state
  id: aggressive_mode_above_temp_sensor_change
  entity_id: !input input_temperature_sensor
  for:
    seconds: 30
- trigger: state
  id: calibration_sensor_change
  entity_id: !input input_temperature_sensor
  for: !input input_calibration_timeout
- trigger: state
  id: calibration_popp_change
  entity_id: !input input_temperature_sensor
  for:
    seconds: 2
- trigger: template
  id: calibration_popp_ping
  value_template: '{% set has_valves_danfoss = input_trvs | select(''is_device_attr'',
    ''manufacturer'', ''Danfoss'') | list  %} {% set has_valves_popp = input_trvs
    | select(''is_device_attr'', ''manufacturer'', ''Popp'') | list %} {% set valves_hive
    = input_trvs | select(''is_device_attr'', ''manufacturer'', ''Hive'') | list %}

    {% set has_valves = (has_valves_danfoss + has_valves_popp + valves_hive) | count
    > 0 %}

    {{ has_valves and is_temperature_sensor_defined and now().strftime(''%M'') | int
    % 10 == 0 }}

    '
- trigger: template
  id: temperature_change_heating_adjustment
  value_template: "{% set timestamp = now() %}\n{% set current_day = timestamp.strftime('%a')
    %} {% set current_time = timestamp.strftime('%H:%M') %}\n{% set plan = input_adjustments
    | rejectattr('time', 'undefined') \n    | selectattr('time','eq', current_time
    | string)\n    | sort(attribute='time', reverse = true)\n    | list  %}\n\n{{
    plan | count > 0 and now() < now().replace(second=2) }}\n"
- trigger: template
  value_template: "{% if not input_liming_protection%}\n  {{ false }}\n{% else %}\n
    \ {% set enable_liming = true %}\n  {% if input_mode_winter != none %}\n    {%
    set enable_liming = is_state(input_mode_winter,'on') or input_liming_in_winter
    %}\n  {% endif %}\n\n  {% set is_liming_day = input_liming_protection_day == now().strftime('%a')
    %}\n  {% set is_liming_time = input_liming_protection_time[:-3] in now().strftime('%H:%M')
    %}\n\n  {{ enable_liming and is_liming_day and is_liming_time }}\n{% endif %}\n"
  id: temperature_change_liming_protection_on
- trigger: template
  value_template: "{% if not input_liming_protection%}\n  {{ false }}\n{% else %}\n
    \ {% set enable_liming = true %}\n  {% if input_mode_winter != none %}\n    {%
    set enable_liming = is_state(input_mode_winter,'on') or input_liming_in_winter
    %}\n  {% endif %}\n\n  {% set is_liming_day = input_liming_protection_day == now().strftime('%a')
    %}\n  {% set is_liming_time = input_liming_protection_time[:-3] in now().strftime('%H:%M')
    %}\n\n  {{ not (enable_liming and is_liming_day and is_liming_time) }}\n{% endif
    %}\n"
  id: temperature_change_liming_protection_off
- trigger: template
  id: temperature_change_frost_protection_on
  for: !input input_frost_protection_duration
  value_template: "{% set now_ts = now() %} {% set frost_protection_timestamp = as_datetime(now_ts)
    - timedelta(**input_frost_protection_duration) %} {% if frost_protection_timestamp
    == now_ts %}\n  {{ false }}\n{% else %}\n  \n  {% set relevant_entities = [input_presence_sensor]
    + [input_mode_guest] + input_persons %}\n  {% set relevant_entities_count = relevant_entities
    | reject('eq',none) | list | count %}\n\n  {% if relevant_entities_count > 0 %}\n
    \   {% set presence_count = [input_presence_sensor] \n        | reject('eq',none)\n
    \       | reject('is_state','on')\n        | list\n        | count %}\n\n    {%
    set guest_mode_count = [input_mode_guest] \n        | reject('eq',none)\n        |
    reject('is_state','on')\n        | list\n        | count %}\n\n    {% set person_count
    = input_persons\n        | reject('is_state','home')\n        | list\n        |
    count %}\n\n    {{ presence_count + guest_mode_count + person_count == relevant_entities_count
    }}\n  {% else %}\n    {{ false }}\n  {% endif %}\n{% endif %}\n"
variables:
  input_trvs: !input input_trvs
  input_hvac_mode: !input input_hvac_mode
  input_temperature_sensor: !input input_temperature_sensor
  input_temperature_comfort: !input input_temperature_comfort
  input_temperature_comfort_entity: '{{ iif(input_temperature_comfort == [], none,
    input_temperature_comfort) }}'
  input_temperature_comfort_static: !input input_temperature_comfort_static
  input_temperature_eco: !input input_temperature_eco
  input_temperature_eco_entity: '{{ iif(input_temperature_eco == [], none, input_temperature_eco)
    }}'
  input_temperature_eco_static: !input input_temperature_eco_static
  input_frost_protection_temp: !input input_frost_protection_temp
  input_frost_protection_duration: !input input_frost_protection_duration
  input_liming_protection: !input input_liming_protection
  input_liming_protection_day: !input input_liming_protection_day
  input_liming_protection_time: !input input_liming_protection_time
  input_liming_in_winter: !input input_liming_in_winter
  input_schedulers: !input input_schedulers
  input_scheduler_selector: !input input_scheduler_selector
  input_presence_sensor: !input input_presence_sensor
  input_scheduler_presence: !input input_scheduler_presence
  input_presence_reaction_off_time: !input input_presence_reaction_off_time
  input_presence_reaction_on_time: !input input_presence_reaction_on_time
  input_windows: !input input_windows
  input_windows_reaction_time_open: !input input_windows_reaction_time_open
  input_windows_reaction_time_close: !input input_windows_reaction_time_close
  input_window_open_temperature: !input input_window_open_temperature
  input_party_legacy_restore: !input input_party_legacy_restore
  input_window_legacy_restore: !input input_window_legacy_restore
  is_legacy_restore: '{{ input_party_legacy_restore or input_window_legacy_restore
    }}'
  input_mode_winter: !input input_mode_winter
  input_invert_winter_mode_value: !input input_invert_winter_mode_value
  input_mode_outside_temperature: !input input_mode_outside_temperature
  input_mode_outside_temperature_threshold: !input input_mode_outside_temperature_threshold
  input_mode_room_temperature: !input input_mode_room_temperature
  input_mode_room_temperature_threshold: !input input_mode_room_temperature_threshold
  input_proximity: !input input_proximity
  input_persons: !input input_persons
  input_mode_guest: !input input_mode_guest
  input_people_entering_home_duration: !input input_people_entering_home_duration
  input_people_leaving_home_duration: !input input_people_leaving_home_duration
  input_mode_party: !input input_mode_party
  input_force_max_temperature: !input input_force_max_temperature
  input_force_eco_temperature: !input input_force_eco_temperature
  input_calibration_delta: !input input_calibration_delta
  input_calibration_generic: !input input_calibration_generic
  input_calibration_step_size: !input input_calibration_step_size
  input_calibration_key_word: !input input_calibration_key_word
  input_generic_calibration_offset: !input input_generic_calibration_offset
  input_aggressive_mode_offset: !input input_aggressive_mode_offset
  input_aggressive_mode_range: !input input_aggressive_mode_range
  input_aggressive_mode_calibration: !input input_aggressive_mode_calibration
  input_away_offset: !input input_away_offset
  is_scheduler_away_mode: !input input_away_scheduler_mode
  is_presence_away_mode: !input input_away_presence_mode
  presence_ignor_people: !input input_away_presence_ignor_people
  input_adjustments: !input input_adjustments
  is_reset_temperature: !input input_reset_temperature
  is_off_instead_min: !input input_off_instead_of_eco
  is_not_off_but_min: !input input_min_instead_of_off
  is_fahrenheit: !input input_fahrenheit
  is_heat_only_if_below_real_temp: !input input_off_if_above_room_temperature
  is_physical_change_enabled: !input input_physical_change
  is_off_if_nobody_home: !input input_off_if_nobody_home
  input_action_call_delay: !input input_action_call_delay
  input_custom_action: !input input_custom_action
  input_startup_delay: !input input_startup_delay
  input_fully_open_difference: !input input_fully_open_difference
  input_valve_opening_keyword: !input input_valve_opening_keyword
  input_valve_positioning_step_size: !input input_valve_positioning_step_size
  input_valve_positioning_mode: !input input_valve_positioning_mode
  input_valve_positioning_timeout: !input input_valve_positioning_timeout
  is_temperature_sensor_defined: '{{ input_temperature_sensor != [] }}'
  invalid_states: '{{ [''unknown'', ''unavailable''] }}

    '
  value_temperature_sensor: "{% if is_temperature_sensor_defined %}\n  {{ states(input_temperature_sensor)
    }}\n{% else %}\n  {{ 'unknown' }}\n{% endif %}\n"
  valid_temperature_sensor: '{{ value_temperature_sensor not in invalid_states }}

    '
  factor: '{{ iif(input_hvac_mode == ''cool'', -1, 1) | int }}'
  current_time_stamp: '{{ now() }}'
  is_metric: '{{ not is_temperature_sensor_defined or (is_temperature_sensor_defined
    and state_attr(input_temperature_sensor,VAR_UNIT_OF_MEASUREMENT) == ''°C'') }}'
  up_time_sensor: '{{ integration_entities(''uptime'') | first | default(none) }}'
  is_uptime_defined: '{{ up_time_sensor != none }}'
  uptime: "{% if is_uptime_defined %}\n  {{ states(up_time_sensor) | as_datetime }}\n{%
    else %}\n  {{ current_time_stamp | as_datetime }}\n{% endif %}\n"
  startup_delay: "{% set start_delay_seconds = timedelta(**input_startup_delay).total_seconds()
    %}\n{% if not is_uptime_defined or start_delay_seconds == 0 %}\n  {{ none }}\n{%
    else %}\n  {% set difference =  (current_time_stamp | as_datetime - uptime | as_datetime).total_seconds()
    %}\n  {% set real_start_delay = (start_delay_seconds - difference) %}\n\n  {{
    iif(real_start_delay > 0, real_start_delay, none) }}\n{% endif %}\n"
  state_outside_temp: "{% if input_mode_outside_temperature == none %}\n  {{ none
    }}\n{% else %}\n  {% set outside_state = false %}\n  {% set use_room_temp = input_mode_room_temperature
    and valid_temperature_sensor %}\n  {% set room_state = iif(use_room_temp, false,
    true) %}\n\n  {% set state = states(input_mode_outside_temperature) %}\n  {% set
    state = iif(is_number(state) == true, state, state_attr(input_mode_outside_temperature,'temperature'))%}\n\n
    \ {% if is_number(state) %}\n    {% set outside_state = (state | float - input_mode_outside_temperature_threshold
    | float) * factor < 0 %}\n  {% endif %}\n\n  {% if use_room_temp %}\n    {% set
    state = states(input_temperature_sensor) %}\n\n    {% if is_number(state) %}\n
    \     {% set room_state = (state | float - input_mode_room_temperature_threshold
    | float) * factor < 0 %}\n    {% endif %}\n  {% endif %}\n\n  {{ room_state and
    outside_state }}\n{% endif %}\n"
  state_ahc: "{% set result = true %} {% if input_mode_winter != none %}\n  {% set
    activation_state = iif(input_invert_winter_mode_value, 'off', 'on') %}\n  {% set
    result = is_state(input_mode_winter, activation_state) %}\n{% endif %}\n{{ iif(state_outside_temp
    == none, result, result and state_outside_temp) }}\n"
  is_proximity_defined: '{{ input_proximity != none }}'
  state_proximity_arrived: "{% set proximity_entities = device_entities(input_proximity)
    %} {% set is_arrived = proximity_entities  \n    | select('is_state','arrived')
    \n    | expand \n    | selectattr('attributes.device_class', 'eq', 'enum') \n
    \   | list | count > 0 %}\n{{ is_arrived }}\n"
  state_proximity_way_home: "{% set proximity_entities = device_entities(input_proximity)
    %}\n{% set earliest_timestamp = current_time_stamp | as_datetime - timedelta(**input_proximity_duration)
    %} {% set uptime_duration = as_datetime(uptime) + timedelta(**input_proximity_duration)
    %}\n{% if uptime_duration > earliest_timestamp %}\n  {% set earliest_timestamp
    = uptime_duration%}\n{% endif %}\n{% set entities_towards = proximity_entities
    \ \n    | expand \n    | selectattr('attributes.device_class', 'eq', 'enum') \n
    \   | selectattr('last_changed', '<=', earliest_timestamp)\n    | map(attribute='entity_id')
    | select('is_state','towards')\n    | map('regex_replace','_(?=[^_]*$)(.*)', '')\n
    \   | list %}\n\n{% set distances = proximity_entities  \n    | expand \n    |
    selectattr('attributes.device_class', 'eq', 'distance')\n    | map(attribute='state')\n
    \   | reject('eq', 'unknown')\n    | map('int')\n    | select('<=', input_proximity_distance
    | int)\n    | map('string')\n    | list %}\n\n{% set entities_distances = proximity_entities
    \ \n    | expand \n    | selectattr('attributes.device_class', 'eq', 'distance')\n
    \   | selectattr('state', 'in', distances)\n    | map(attribute='entity_id')\n
    \   | map('regex_replace','_(?=[^_]*$)(.*)', '')\n    | list %}\n\n{% set towards_and_in_distance
    = entities_towards | select('in', entities_distances) | list | count > 0 %}\n{{
    towards_and_in_distance }}\n"
  is_person_defined: '{{ input_persons | count > 0 or input_mode_guest != none }}'
  is_guest_mode: '{{ input_mode_guest != none and is_state(input_mode_guest, ''on'')
    }}'
  is_anybody_home: "{% if is_guest_mode %}\n  {{ true }}\n{% elif not is_person_defined
    %}\n  {{ false }}\n{% else %}\n  {% set on_time_delta = current_time_stamp | as_datetime
    - timedelta(**input_people_entering_home_duration) %}\n  {% set off_time_delta
    = current_time_stamp | as_datetime - timedelta(**input_people_leaving_home_duration)
    %}\n\n  {% set uptime_on = as_datetime(uptime) + timedelta(**input_people_entering_home_duration)
    %}\n  {% set uptime_off = as_datetime(uptime) + timedelta(**input_people_leaving_home_duration)
    %}\n\n  {% set result = false %}\n\n  {% if uptime_on > on_time_delta or uptime_off
    > off_time_delta %}\n    {{ input_persons  | expand \n                      |
    selectattr('state', 'eq', 'home') \n                      | list \n                      |
    count > 0 }}\n  {% else %}\n    {% set somebody_is_home = input_persons | expand\n
    \                                       | selectattr('state', 'eq', 'home')\n
    \                                       | selectattr('last_changed', '<=', on_time_delta)\n
    \                                       | list\n                                        |
    count > 0 %}\n\n    {% set somebody_is_leaving = input_persons | expand \n                                            |
    rejectattr('state', 'eq', 'home')\n                                            |
    selectattr('last_changed', '>', off_time_delta) \n                                            |
    list\n                                            | count > 0 %}\n\n    {{ somebody_is_home
    or somebody_is_leaving }}\n  {% endif %}\n{% endif %}\n"
  is_anybody_home_or_proximity: '{{ is_anybody_home or state_proximity_way_home or
    state_proximity_arrived}}'
  active_scheduler: "{% set selected_scheduler = none %} {% set schedules_count =
    input_schedulers | count %}\n{% if schedules_count == 0 %}\n  {% set selected_scheduler
    = none %}\n{% elif schedules_count == 1 or input_scheduler_selector == none %}\n
    \ {% set selected_scheduler = input_schedulers | first %}\n{% elif schedules_count
    > 1 %}\n  {% set selector_value = states(input_scheduler_selector) %}\n\n  {%
    if is_number(selector_value) %}\n    {% set selector_value = iif(selector_value
    | int > schedules_count, schedules_count, selector_value) %}\n    {% set selector_value
    = iif(selector_value | int <= 0, 1, selector_value) %}\n    {% set selected_scheduler
    = input_schedulers[selector_value | int - 1] %}\n  {% elif selector_value in ['on','off']
    %}\n    {% set selected_scheduler = iif(selector_value == 'off', input_schedulers[0],
    input_schedulers[1]) %}\n  {% else %}\n    {% set selected_scheduler = input_schedulers
    | expand | selectattr('attributes.friendly_name', 'eq', selector_value) | map(attribute='entity_id')
    | first | default(none) %}\n    {% if (selected_scheduler == none) %}\n      {%
    set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name',
    'search', '(?i)' + selector_value) | map(attribute='entity_id') | first | default(none)
    %}\n    {% endif %}\n  {% endif %}\n{% endif %}\n{{ selected_scheduler }}\n"
  is_scheduler_defined: '{{ active_scheduler != none }}'
  state_scheduler: '{{ active_scheduler != none and is_state(active_scheduler,''on'')
    }}'
  is_presence_sensor_defined: '{{ input_presence_sensor != none }}'
  is_presence_scheduler_defined: '{{ input_scheduler_presence != none }}'
  state_presence_scheduler: '{{ is_presence_scheduler_defined and is_state(input_scheduler_presence,
    ''on'') }}'
  state_presence_sensor: "{% if not is_presence_sensor_defined %}\n  {{ false }}\n{%
    else %}\n  {% set last_changed = [input_presence_sensor] | expand | map(attribute='last_changed')
    | first %}\n  {% set sensor_state = is_state(input_presence_sensor, 'on') %}\n
    \ {% set reaction_time = iif(sensor_state, input_presence_reaction_on_time, input_presence_reaction_off_time)
    %}\n  {% set min_timestamp = last_changed + timedelta(**reaction_time) %}\n  {%
    set current_ts = current_time_stamp | as_datetime%}\n\n  {% if is_uptime_defined
    and as_datetime(uptime) + timedelta(**reaction_time) > current_ts - timedelta(**reaction_time)
    %}\n    {{ sensor_state }}\n  {% else %}\n    {% set is_limit = min_timestamp
    <= current_ts %}\n\n    {{ (sensor_state == true and is_limit) or (sensor_state
    == false and not is_limit) }}\n  {% endif %}\n{% endif %}\n"
  state_presence: '{{ iif(is_presence_scheduler_defined, state_presence_scheduler
    and state_presence_sensor, state_presence_sensor) }}

    '
  is_force_max_temperature: '{{ input_force_max_temperature != [] and is_state(input_force_max_temperature,
    ''on'') }}'
  is_force_eco_temperature: '{{ input_force_eco_temperature != [] and is_state(input_force_eco_temperature,
    ''on'') }}'
  active_party_entity: '{{ input_mode_party | expand | selectattr(''state'', ''in'',
    [''active'',''on'']) | map(attribute=''entity_id'') | first | default(none) }}'
  state_party: '{{ active_party_entity != none }}'
  party_temp: "{% set pos_party_temp = none %} {% if state_party == true %}\n  {%
    set name = state_attr(active_party_entity,'friendly_name') %}\n  {% set pos_temp
    = name.split(' ') | last %}\n  {% if is_number(pos_temp) %}\n    {% set pos_party_temp
    = pos_temp | float %}\n  {% endif %}\n{% endif %} {{ pos_party_temp }}\n"
  is_away: "{% if is_person_defined and not is_anybody_home_or_proximity %}\n  {{
    (is_scheduler_away_mode and state_scheduler) or (is_presence_away_mode and state_presence_scheduler
    and not state_presence) }}\n{% elif presence_ignor_people and is_presence_away_mode
    %}\n  {{ state_presence_scheduler and not state_presence }}\n{% elif is_presence_away_mode
    and is_person_defined and is_anybody_home_or_proximity and not presence_ignor_people
    %}\n  {{ not state_presence }}\n{% else %}\n  {{ false }}\n{% endif %}\n"
  state_window: "{% set current_ts = current_time_stamp | as_datetime %} {% set on_time_delta
    = current_ts - timedelta(**input_windows_reaction_time_open) %} {% set off_time_delta
    = current_ts - timedelta(**input_windows_reaction_time_close) %}\n{% set has_open_windows
    = input_windows \n    | expand\n    | selectattr('state', 'in', ['on','open','tilted'])\n
    \   | selectattr('last_changed', '<=', on_time_delta)\n    | list\n    | count
    > 0 %}\n\n{% set closed_but_not_in_duration = input_windows \n    | expand\n    |
    selectattr('state', 'in', ['off','closed'])\n    | selectattr('last_changed',
    '>=', off_time_delta)\n    | list\n    | count > 0 %}\n\n{{ has_open_windows or
    closed_but_not_in_duration }}\n"
  is_aggressive_mode: '{{ input_aggressive_mode_offset > 0 }}'
  is_aggressive_mode_calibration: '{{ is_aggressive_mode and input_aggressive_mode_calibration
    and valid_temperature_sensor }}'
  is_frost_protection: "{% set frost_protection_timestamp = as_datetime(current_time_stamp)
    - timedelta(**input_frost_protection_duration) %} {% if frost_protection_timestamp
    == as_datetime(current_time_stamp) %}\n  {{ false }}\n{% else %}\n  {% set relevant_entities
    = [input_presence_sensor] + [input_mode_guest] + input_persons %}\n  {% set relevant_entities_count
    = relevant_entities | reject('eq',none) | list | count %}\n\n  {% if relevant_entities_count
    > 0 %}\n\n    {% set presence_count = [input_presence_sensor] \n        | reject('eq',none)\n
    \       | reject('is_state','on')\n        | expand \n        | selectattr('last_changed',
    '<=', frost_protection_timestamp)\n        | list | count %}\n\n    {% set persons_count
    = input_persons\n        | reject('eq',none)\n        | reject('is_state','home')\n
    \       | expand\n        | selectattr('last_changed', '<=', frost_protection_timestamp)\n
    \       | list | count %}\n\n    {% set guest_mode_count = [input_mode_guest]
    \n        | reject('eq',none)\n        | reject('is_state','on')\n        | expand
    \n        | selectattr('last_changed', '<=', frost_protection_timestamp)\n        |
    list | count %}\n\n    {{ presence_count + guest_mode_count + persons_count ==
    relevant_entities_count }}\n  {% else %}\n    {{ false }}\n  {% endif %}\n{% endif
    %}\n"
  is_liming_protection: "{% if not input_liming_protection%}\n  {{ false }}\n{% else
    %}\n  {% set enable_liming = true %}\n  {% if input_mode_winter != none %}\n    {%
    set enable_liming = is_state(input_mode_winter,'on') or input_liming_in_winter
    %}\n  {% endif %}\n\n  {% set current_ts = current_time_stamp | as_datetime %}\n\n
    \ {% set is_liming_day = input_liming_protection_day == current_ts.strftime('%a')
    %}\n  {% set is_liming_time = input_liming_protection_time[:-3] in current_ts.strftime('%H:%M')
    %}\n\n  {{ enable_liming and is_liming_day and is_liming_time }}\n{% endif %}\n"
  valves: "{{ input_trvs | expand\n    | selectattr('attributes.hvac_modes','search','(?i)'+input_hvac_mode)
    \n    | map(attribute='entity_id') \n    | list }}\n"
  valves_unsupported: '{{ input_trvs | reject(''in'',valves) | list }}

    '
  valves_off_mode: "{{ valves | expand | selectattr('attributes.hvac_modes','search','(?i)off')
    \n    | map(attribute='entity_id') \n    | list }}\n"
  valves_without_off_mode: '{{ valves | reject(''in'',valves_off_mode) | list }}

    '
  valves_tado: '{{ valves | select(''is_device_attr'', ''manufacturer'', ''Tado'')
    | list }}'
  valves_xiaomi_xiaomi: '{{ valves | select(''is_device_attr'', ''manufacturer'',
    ''Xiaomi'') | list }}'
  valves_xiaomi_aqara: '{{ valves | select(''is_device_attr'', ''manufacturer'', ''Aqara'')
    | list }}'
  valves_xiaomi: '{{ valves_xiaomi_xiaomi + valves_xiaomi_aqara }}'
  valves_danfoss: '{{ valves | select(''is_device_attr'', ''manufacturer'', ''Danfoss'')
    | list }}'
  valves_popp: '{{ valves | select(''is_device_attr'', ''manufacturer'', ''Popp'')
    | list }}'
  valves_hive: '{{ valves | select(''is_device_attr'', ''manufacturer'', ''Hive'')
    | list }}'
  valves_dph: '{{ valves_danfoss + valves_popp + valves_hive }}'
  valves_calibration_common: '{{ valves | reject(''in'', valves_tado + valves_dph
    + valves_xiaomi) | list }}'
  last_comfort_entity_change: '{{ [input_temperature_comfort_entity] | expand | map(attribute=''last_changed'')
    | list | first | default(none) }}'
  last_eco_entity_change: '{{ [input_temperature_eco_entity] | expand | map(attribute=''last_changed'')
    | list | first | default(none) }}'
  latest_entry_today: "{% set scheduler_name = none %} {% if active_scheduler != none
    %}\n  {% set scheduler_name = state_attr(active_scheduler,'friendly_name') %}\n{%
    endif %}\n{% set current_ts = current_time_stamp | as_datetime %}\n{% set current_day
    = current_ts.strftime('%a') %} {% set current_time = current_ts.strftime('%H:%M')
    %}\n{% set plan = input_adjustments | rejectattr('time', 'undefined') \n    |
    selectattr('time','<=', current_time| string)\n    | list  %}\n\n{% set selected_entries_days_and_schedule
    = plan | rejectattr('days','==',Undefined) | selectattr('days','search',current_day)
    \n                           | rejectattr('scheduler','==',Undefined) | selectattr('scheduler','in',scheduler_name)
    \n                           | list %}\n\n{% set selected_entries_days = plan
    | rejectattr('days','==',Undefined) | selectattr('days','search',current_day)
    \n                                    | selectattr('scheduler','in',[Undefined])\n
    \                                   | list %}\n\n{% set selected_entries_schedule
    = plan | rejectattr('scheduler','==',Undefined) | selectattr('scheduler','in',scheduler_name)
    \n                                        | selectattr('days','in',[Undefined])\n
    \                                       | list %}\n\n{% set selected_entries_time_only
    = plan | selectattr('days','in',[Undefined]) \n                              |
    selectattr('scheduler','in',[Undefined]) \n                              | list
    %}\n\n{% set selected_entries = selected_entries_days_and_schedule + selected_entries_days
    + selected_entries_schedule + selected_entries_time_only %}\n{% if selected_entries
    | count > 0%}\n  {{ selected_entries | sort(attribute='time', reverse = true)
    | first  }}\n{% else %}\n  {{ none }}\n{% endif %}\n"
  latest_entry_day_before: "{% set timestamp = as_datetime(current_time_stamp).replace(hour=23,minute=59)
    + timedelta(days=-1) %}\n{% set scheduler_name = none %} {% if active_scheduler
    != none %}\n  {% set scheduler_name = state_attr(active_scheduler,'friendly_name')
    %}\n{% endif %}\n{% set current_day = timestamp.strftime('%a') %} {% set current_time
    = timestamp.strftime('%H:%M') %}\n{% set plan = input_adjustments | rejectattr('time',
    'undefined') \n    | selectattr('time','<=', current_time| string)\n    | list
    \ %}\n\n{% set selected_entries_days_and_schedule = plan | rejectattr('days','==',Undefined)
    | selectattr('days','search',current_day) \n                           | rejectattr('scheduler','==',Undefined)
    | selectattr('scheduler','in',scheduler_name) \n                           | list
    %}\n\n{% set selected_entries_days = plan | rejectattr('days','==',Undefined)
    | selectattr('days','search',current_day) \n                                    |
    selectattr('scheduler','in',[Undefined])\n                                    |
    list %}\n\n{% set selected_entries_schedule = plan | rejectattr('scheduler','==',Undefined)
    | selectattr('scheduler','in',scheduler_name) \n                                        |
    selectattr('days','in',[Undefined])\n                                        |
    list %}\n\n{% set selected_entries_time_only = plan | selectattr('days','in',[Undefined])
    \n                              | selectattr('scheduler','in',[Undefined]) \n
    \                             | list %}\n\n{% set selected_entries = selected_entries_days_and_schedule
    + selected_entries_days + selected_entries_schedule + selected_entries_time_only
    %}\n{% if selected_entries | count > 0%}\n  {{ selected_entries | sort(attribute='time',
    reverse = true) | first  }}\n{% else %}\n  {{ none }}\n{% endif %}\n"
  entry: '{{ iif(latest_entry_today != none, latest_entry_today, latest_entry_day_before)
    }}'
  entry_time: "{% if entry != none  %}\n  {% set entry_hour = entry['time'].split(':')[0]
    | int %}\n  {% set entry_minute = entry['time'].split(':')[1] | int %}\n  {{ as_datetime(current_time_stamp).replace(hour=entry_hour,
    minute=entry_minute, second=0, microsecond=0) + timedelta(days=iif(latest_entry_today
    == none,-1,0))  }}\n{% endif %}\n"
  entry_comfort_temp: "{% if entry != none and 'comfort' in entry.keys() and (last_comfort_entity_change
    == none or as_datetime(entry_time) > as_datetime(last_comfort_entity_change))
    %}\n  {% set entry_temp = entry['comfort']%}  \n  {% if is_number(entry_temp)
    %}\n    {{ entry_temp }}\n  {% elif states[entry_temp] != none %}\n    {{ states(entry_temp)
    }}\n  {% endif %}\n{% else %}\n  {{ none }}\n{% endif %}\n"
  entry_eco_temp: "{% if entry != none and 'eco' in entry.keys() and (last_eco_entity_change
    == none or as_datetime(entry_time) > as_datetime(last_eco_entity_change)) %}\n
    \ {% set entry_temp = entry['eco']%}  \n  {% if is_number(entry_temp) %}\n    {{
    entry_temp }}\n  {% elif states[entry_temp] != none %}\n    {{ states(entry_temp)
    }}\n  {% endif %}\n{% else %}\n  {{ none }}\n{% endif %}\n"
  entry_calibration: "{% if entry != none and 'calibration' in entry.keys() %}\n  {{
    entry['calibration'] == 'on' }}\n{% else %}\n  {{ true }}\n{% endif %}\n"
  trigger_id_defined: '{{ trigger.id is defined }}'
  is_calibration_trigger: "{% if valves_dph | count > 0 and trigger_id_defined and
    trigger.id in ['calibration_popp_ping','calibration_popp_change'] %}\n  {{ true
    }}\n{% elif is_aggressive_mode_calibration and trigger_id_defined and 'aggressive_mode'
    in trigger.id %}\n  {{ true }}\n{% else %}\n  {{ trigger_id_defined and 'calibration'
    in trigger.id and not trigger.id == 'calibration_aggressive_mode_thermostat_temp_change'
    }}\n{% endif %}\n"
  is_generic_calibration_trigger: '{{ is_calibration_trigger and input_calibration_generic
    }}'
  is_generic_calibration: '{{ is_generic_calibration_trigger and entry_calibration
    and valid_temperature_sensor }}'
  is_aggressive_mode_trigger: '{{ is_aggressive_mode and trigger_id_defined and ''aggressive_mode''
    in trigger.id }}'
  is_change_trigger: "{{ trigger_id_defined and \n    'temperature_change' in trigger.id
    and \n    ('presence' in trigger.id or \n    'scheduler' in trigger.id or \n    'proximity'
    in trigger.id or \n    'person' in trigger.id or\n    '_ds' in trigger.id)\n    and
    not trigger.id == 'temperature_change_valve_target' }}\n"
  set_max_temperature: '{{ is_force_max_temperature or is_liming_protection }}'
  is_pysical_change: "{{  trigger_id_defined \n    and trigger.id == 'temperature_change_valve_target'
    \n    and is_physical_change_enabled\n    and not state_window\n    and not set_max_temperature
    }}\n"
  is_adjustment_trigger: '{{ trigger_id_defined and trigger.id == ''temperature_change_heating_adjustment''
    and (entry_comfort_temp != none or entry_eco_temp != none) }}'
  is_reset: "{{ (is_reset_temperature and is_change_trigger) or \n    is_pysical_change
    or is_adjustment_trigger }}\n"
  is_changes_trigger: "{% if state_window %}\n  {% if trigger_id_defined and 'temperature_change_window_on'
    in trigger.id %}\n    {{ true }}\n  {% elif trigger_id_defined and 'temperature_change_window_off'
    not in trigger.id %}\n    {{ false }}\n  {% endif %}\n{% elif trigger.platform
    == none %}\n  {{ true }}\n{% elif trigger_id_defined and trigger.id == 'temperature_change_valve_target'
    %}\n  {{ false }}\n{% elif is_heat_only_if_below_real_temp and trigger_id_defined
    and 'above_temp' in trigger.id %}\n  {{ true }}\n{% elif is_aggressive_mode_calibration
    and is_aggressive_mode_trigger %}\n  {{ false }}\n{% elif is_aggressive_mode_trigger
    %}\n  {{ true }}\n{% elif is_generic_calibration %}\n  {{ true }}\n{% else %}\n
    \ {{ trigger_id_defined and 'temperature_change' in trigger.id}}\n{% endif %}\n"
  is_scene_create_trigger: '{{ trigger_id_defined and (("window_on" in trigger.id
    and not state_party) or ("party_on" in trigger.id and not state_window)) }}

    '
  is_scene_apply_trigger: '{{ trigger_id_defined and ("window_off" in trigger.id or
    "party_off" in trigger.id) and not is_legacy_restore and not (state_window or
    state_party) }}

    '
  is_scene_destroy_trigger: '{{ (is_change_trigger or trigger.id == ''temperature_change_heating_adjustment'')
    and (state_window or state_party) }}

    '
  scene_entities: '{{ valves }}'
  scene_window_id: '{{ ''scene.'' + this.entity_id | replace(''automation.'','''')
    | replace(''.'',''_'') + ''_window'' }}'
  scene_party_id: '{{ ''scene.'' + this.entity_id | replace(''automation.'','''')
    | replace(''.'',''_'') + ''_party'' }}'
  scenes_all: '{{ [scene_window_id, scene_party_id] }}'
  scene_to_apply: "{% if is_scene_apply_trigger and \"window_off\" in trigger.id %}\n
    \ {{ scene_window_id }}\n{% elif is_scene_apply_trigger and \"party_off\" in trigger.id
    %}\n  {{ scene_party_id }}\n{% else %}\n  {{ none }}\n{% endif %}\n"
  scenes_to_destroy: "{% set scenes = [] %} {% if is_scene_destroy_trigger %}\n  {%
    set scenes = iif(state_window, scenes + [scene_window_id], scenes) %}\n  {% set
    scenes = iif(state_party, scenes + [scene_party_id], scenes) %}\n{% endif %} {{
    scenes }}\n"
  scene_to_create: '{{ iif(is_scene_create_trigger and "window_on" in trigger.id,
    scene_window_id, scene_party_id) }}

    '
  set_comfort: "{% if state_party or is_force_max_temperature %}\n  {{ true }}\n{%
    elif is_force_eco_temperature %}\n  {{ false }}\n{% elif is_away %}\n  {{ true
    }}\n{% elif not is_scheduler_defined and not is_presence_sensor_defined %}\n  {{
    is_anybody_home_or_proximity }}\n{% else %}\n  {% set comfort_state = state_scheduler
    or state_presence %}\n\n  {% if is_person_defined or is_proximity_defined %}\n
    \   {{ is_anybody_home_or_proximity and comfort_state }}\n  {% else %}\n    {{
    comfort_state }}\n  {% endif %}\n{% endif %}\n"
  mode: "{% if not state_ahc %}\n  {{ 'off' }}\n{% elif state_window and input_window_open_temperature
    | int == 0 and not set_max_temperature %}\n  {{ 'off' }}\n{% elif is_off_instead_min
    and not set_comfort %} \n  {{ 'off' }}\n{% elif is_off_if_nobody_home and is_person_defined
    and not is_anybody_home_or_proximity and not set_comfort %}\n  {{ 'off' }}\n{%
    else %}\n  {{ input_hvac_mode }}\n{% endif %}\n"
  temperature_comfort_of_entity: "{% if(input_temperature_comfort_entity != none)
    %}\n  {{ states(input_temperature_comfort_entity) | float }}\n{% else %}\n  {{
    none }}\n{% endif %}\n"
  temperature_eco_of_entity: "{% if(input_temperature_eco_entity != none) %}\n  {{
    states(input_temperature_eco_entity) | float }}\n{% else %}\n  {{ none }}\n{%
    endif %}\n"
  temperature_comfort: '{{ [entry_comfort_temp, temperature_comfort_of_entity, input_temperature_comfort_static]
    | reject(''=='', none) | first }}'
  temperature_away: '{{ temperature_comfort | float - input_away_offset }}'
  temperature_eco: '{{ [entry_eco_temp, temperature_eco_of_entity, input_temperature_eco_static]
    | reject(''=='', none) | first }}'
  target_temperature: "{% if state_window and input_window_open_temperature > 0 %}\n
    \ {{ input_window_open_temperature }}\n{% elif state_party %}\n  {{ iif(party_temp
    != none, party_temp, temperature_comfort) }}\n{% elif is_frost_protection %}\n
    \ {{ input_frost_protection_temp }}\n{% else %}\n  {{ iif(set_comfort, iif(is_away,
    temperature_away, temperature_comfort), temperature_eco) }}\n{% endif %}\n"
  changes: "{% set n = namespace(dict=[]) %}\n{% set original_mode = mode %}\n{% if
    not is_changes_trigger %}\n  {{ n.dict }}\n{% else %}\n  {% for valve in input_trvs
    %}\n\n    {% set current_valve_temp = state_attr(valve, 'current_temperature')
    | float(20) %}\n    {% set current_valve_target_temp = state_attr(valve, 'temperature')
    | float(temperature) %}\n    {% set current_valve_mode = states(valve) %}\n    {%
    set min_temp = state_attr(valve, 'min_temp') | float(5) %}\n    {% set max_temp
    = state_attr(valve, 'max_temp') | float(30) %}\n\n    {% set valve_temp = target_temperature
    %}\n\n    {% set dont_turn_off = \n          valve in valves_without_off_mode
    or \n          is_not_off_but_min or \n          (state_window and input_window_open_temperature
    > 0) or\n          set_max_temperature %}\n\n    {% set ref_temp = current_valve_temp
    %}\n    {% if valid_temperature_sensor %}\n      {% set ref_temp = value_temperature_sensor
    | float(current_valve_temp) %}\n    {% endif %}\n\n    {% if is_heat_only_if_below_real_temp
    and iif(factor == 1, target_temperature <= ref_temp, target_temperature >= ref_temp)
    %}\n      {% set mode = 'off' %}\n    {% endif %}\n\n    {% set valve_mode = iif(mode
    == 'off' and dont_turn_off, current_valve_mode, mode) %}\n\n    {% if mode !=
    'off' %}\n\n      {% if is_aggressive_mode and not is_aggressive_mode_calibration
    %}\n\n        {% set temp_diff = valve_temp - ref_temp %}\n\n        {% if temp_diff
    * factor < input_aggressive_mode_range * -1 %}\n          {% set valve_temp =
    valve_temp - input_aggressive_mode_offset * factor %}\n        {% elif temp_diff
    * factor > input_aggressive_mode_range %}\n          {% set valve_temp = valve_temp
    + input_aggressive_mode_offset * factor %}\n        {% endif %}\n\n      {% endif
    %}\n\n      {% if input_calibration_generic %}\n\n        {% if current_valve_temp
    != ref_temp %}\n          {% set offset = current_valve_temp - ref_temp %}\n\n
    \         {% set offset = iif(offset > float(input_generic_calibration_offset),
    input_generic_calibration_offset, offset) %}\n          {% set offset = iif(offset
    < float(input_generic_calibration_offset) * -1, input_generic_calibration_offset
    * -1, offset) %}\n\n          {% set temp_with_offset = float(valve_temp) + float(offset)
    %}\n          {% set step = state_attr(valve, 'target_temp_step') | float(0.5)
    %}\n\n          {% set temp_with_offset = (temp_with_offset | float(0) / float(step))
    | round(0) * float(step) %}\n\n          {% set valve_temp = iif(input_calibration_step_size
    == 'full', float(temp_with_offset) | round(), temp_with_offset | round(1)) %}\n\n
    \       {% endif %}\n      {% endif %}\n\n    {% endif %}\n\n    {% if mode ==
    'off' and dont_turn_off %}\n      {% set valve_temp = min_temp %}\n    {% endif
    %}\n\n    {% set valve_temp = iif(set_max_temperature, max_temp, valve_temp) %}\n
    \   {% set valve_temp = iif(valve_temp > max_temp, max_temp, valve_temp) %}\n
    \   {% set valve_temp = iif(valve_temp < min_temp, min_temp, valve_temp) %}\n\n
    \   {% if current_valve_mode != valve_mode or current_valve_target_temp != valve_temp
    %}\n      {% set n.dict = n.dict + [(valve, [{'mode': valve_mode , 'temp': valve_temp}])]
    %}\n    {% endif %}\n\n  {% endfor %}\n\n  {% set mode = original_mode %}\n\n
    \ {{ dict.from_keys(n.dict) }}\n{% endif %}\n"
  positioning: "{% set n = namespace(dict=[]) %}\n{% if input_valve_positioning_mode
    == 'off' %}\n  {{ n.dict }}\n{% else %}\n  {% for valve in input_trvs %}\n\n    {%
    set current_temp = state_attr(valve, 'current_temperature') | float(none) %}\n
    \   {% set target_temp = state_attr(valve, 'temperature') | float(none) %}\n\n
    \   {% set open_valve_entity = device_entities(device_id(valve)) | expand \n        |
    selectattr('domain','in','number') \n        | selectattr('entity_id', 'search',
    input_valve_opening_keyword)\n        | map(attribute='entity_id') \n        |
    list | first | default(none) %}\n\n    {%  if open_valve_entity != none and current_temp
    != none and target_temp != none and\n        (\n          is_force_max_temperature
    or \n          ([open_valve_entity] | expand | map(attribute='last_changed') |
    first) + timedelta(**input_valve_positioning_timeout) <= now() or\n          (trigger_id_defined
    and 'temperature_change_window_on' in trigger.id)\n        )\n    %}\n\n      {%
    set opening = 100 %}\n      {% set difference = target_temp - current_temp %}\n
    \     {% set step_size = input_valve_positioning_step_size | int %}\n\n      {%
    if input_fully_open_difference > 0 and not is_force_max_temperature %}\n\n        {%
    set opening_regular = (100 / input_fully_open_difference) * difference %}\n        {%
    set opening_pessimistic = sqrt(((100 / input_fully_open_difference) * difference)
    | abs) * 10 %}\n        {% set opening_optimistic = ((100 / input_fully_open_difference)
    * difference)**2 / 100 %}\n\n        {% set opening = opening_regular %}\n        {%
    set opening = iif(input_valve_positioning_mode == 'pessimistic', opening_pessimistic,
    opening) %}\n        {% set opening = iif(input_valve_positioning_mode == 'optimistic',
    opening_optimistic, opening) %}\n\n        {% set opening = iif(difference >=
    input_fully_open_difference, 100, opening) %}\n        {% set opening = iif(difference
    < 0, 0, opening) %}\n        {% set opening = ((opening + step_size / 2) // step_size
    * step_size) | int %}\n      {% endif %}\n\n      {% set open_valve_entity_value
    = states(open_valve_entity) | int %}\n\n      {% if open_valve_entity_value !=
    opening %}\n        {% set n.dict = n.dict + [(valve, [{'entity': open_valve_entity
    , 'value': opening}])] %}\n      {% endif %}\n\n    {% endif %}\n  {% endfor %}\n\n
    \ {{ dict.from_keys(n.dict) }}\n{% endif %}\n"
  reset_data: "{% set result = [] %} {% if is_adjustment_trigger %}\n  {% if entry_comfort_temp
    != none and input_temperature_comfort_entity != none %}\n    {% set result = result
    + [{'entity': input_temperature_comfort_entity, 'temp': entry_comfort_temp}] %}\n
    \ {% endif %}\n  {% if entry_eco_temp != none and input_temperature_eco_entity
    != none %}\n    {% set result = result + [{'entity': input_temperature_eco_entity,
    'temp': entry_eco_temp}] %}\n  {% endif %}\n{% else %}\n  {% set entity = none
    %}\n  {% if is_reset and set_comfort %}\n    {% set entity = iif(is_pysical_change,
    input_temperature_comfort_entity, input_temperature_eco_entity) %}\n  {% elif
    is_reset and not set_comfort %}\n    {% set entity = iif(is_pysical_change, input_temperature_eco_entity,
    input_temperature_comfort_entity) %}\n  {% endif %}\n\n  {% set temp_r = none
    %}\n  {% if is_pysical_change %}\n    {% set temp_r = state_attr(trigger.to_state.entity_id,'temperature')
    %}\n  {% else %}\n  {% set temp_r = iif(is_reset and entity == input_temperature_eco_entity,
    \n      input_temperature_eco_static, input_temperature_comfort_static) %}\n  {%
    endif %}\n\n  {% if entity != none and temp_r != none %}\n    {% set result =
    result + [{'entity': entity, 'temp': temp_r}] %}\n  {% endif %}\n{% endif %}\n{{
    result }}\n"
  is_reset_trigger: '{{ is_reset and reset_data | count > 0 }}'
  is_native_calibration: '{{ not input_calibration_generic and entry_calibration and
    valid_temperature_sensor }}'
  is_native_calibration_trigger: '{{ is_calibration_trigger and is_native_calibration
    }}'
  rounding_mode: "{% if is_number(input_calibration_step_size) or input_calibration_step_size
    == 'full' %}\n  {{ 'manual' }}\n{% else %}\n  {{ 'auto' }}\n{% endif %}\n"
  calibration_tado: "{% set n = namespace(dict=[]) %}\n{% if is_native_calibration_trigger
    %}\n  {% for valve in valves_tado %}\n\n    {% set offset_old = state_attr(valve,
    'offset_celsius') | float(0) %}\n    {% set local_temperature = state_attr(valve,
    'current_temperature') | float %}\n    {% set calibration_sensor_temperature =
    value_temperature_sensor | float %}\n    \n    {% set offset_new = (-(local_temperature
    - calibration_sensor_temperature) + offset_old) %}\n\n    {% if is_aggressive_mode_calibration
    %}           \n      {% set temp_diff = state_attr(valve,'temperature') | float(target_temperature)
    - calibration_sensor_temperature %}\n\n      {% if temp_diff * factor < input_aggressive_mode_range
    * -1 %}\n        {% set offset_new = offset_new + input_aggressive_mode_offset
    * factor %}\n      {% elif temp_diff * factor > input_aggressive_mode_range %}\n
    \       {% set offset_new = offset_new - input_aggressive_mode_offset * factor
    %}\n      {% endif %}\n    {% endif %}\n\n    {% set t_min = -10.9 %}\n    {%
    set t_max = 10.9 %}\n\n    {% set offset_new = iif(offset_new > t_max, t_max,
    offset_new) %}\n    {% set offset_new = iif(offset_new < t_min, t_min, offset_new)
    %}\n\n    {% set offset_new = offset_new | round(1) %}\n\n    {% if (float(offset_old)
    - float(offset_new)) | abs >= float(input_calibration_delta) %}\n      {% set
    n.dict = n.dict + [(valve, [{'value': offset_new }])] %}\n    {% endif %}\n\n
    \ {% endfor %}\n{% endif %}\n{{ dict.from_keys(n.dict) }}\n"
  calibration_xiaomi: "{% set n = namespace(dict=[]) %}\n{% if is_native_calibration_trigger
    %}\n  {% for valve in valves_xiaomi %}\n\n    {% set calibration_entities = device_entities(device_id(valve))
    |\n                                expand | selectattr('domain','in','number')
    |\n                                selectattr('entity_id', 'search', input_calibration_key_word)
    |\n                                map(attribute='entity_id') | list %}\n\n    {%
    if calibration_entities | count > 0 %}\n\n      {% set calibration_entity = calibration_entities
    | first %}\n      {% set offset_old = states(calibration_entity) | float(0) %}\n
    \     {% set offset_new = value_temperature_sensor | float %}\n      \n      {%
    set step = state_attr(calibration_entity, 'step') | float(1) %}\n      {% if rounding_mode
    == 'manual' %} \n          {% set step = input_calibration_step_size | float(1)
    %}\n      {% endif %}\n\n      {% set min_val = state_attr(calibration_entity,'min')
    | float(0) %}\n      {% set max_val = state_attr(calibration_entity,'max') | float(55)
    %}\n      \n      {% if is_aggressive_mode_calibration %}           \n        {%
    set temp_diff = state_attr(valve,'temperature') | float(target_temperature) -
    value_temperature_sensor | float %}\n\n        {% if temp_diff * factor < input_aggressive_mode_range
    * -1 %}\n          {% set offset_new = offset_new + input_aggressive_mode_offset
    * factor %}\n        {% elif temp_diff * factor > input_aggressive_mode_range
    %}\n          {% set offset_new = offset_new - input_aggressive_mode_offset *
    factor %}\n        {% endif %}\n      {% endif %}\n\n      {% set round_size =
    iif('.' in (step | string), (step | string).split('.')[1] | length, 0) %}\n      {%
    set offset_new = ((offset_new | float(0) / step) | round(0) * step) | round(round_size)
    | float %}\n\n      {% set offset_new = iif(offset_new > max_val, max_val, offset_new)
    %}\n      {% set offset_new = iif(offset_new < min_val, min_val, offset_new) %}\n\n
    \     {% if (float(offset_old) - float(offset_new)) | abs >= float(input_calibration_delta)
    %}\n        {% set n.dict = n.dict + [(calibration_entity, [{'value': offset_new,
    'valve': valve}])] %}\n      {% endif %}\n    {% endif %}\n\n  {% endfor %}\n{%
    endif %}\n{{ dict.from_keys(n.dict) }}\n"
  calibration_dph: "{% set n = namespace(dict=[]) %} {% if is_native_calibration_trigger
    %}\n\n  {% for valve in valves_dph %}\n\n    {% set calibration_entity = device_entities(device_id(valve))
    |\n                                expand | selectattr('domain','in','number')
    |\n                                selectattr('entity_id', 'search', input_calibration_key_word)
    |\n                                map(attribute='entity_id') | first %}\n\n    {%
    set min_val = state_attr(calibration_entity,'min')%}\n    {% set max_val = state_attr(calibration_entity,'max')%}\n
    \   \n    {% set step = state_attr(calibration_entity, 'step') | float(1) %}\n
    \   {% if rounding_mode == 'manual' %} \n        {% set step = input_calibration_step_size
    | float(1) %}\n    {% endif %}\n\n    {% set current_temp = state_attr(valve,'current_temperature')
    | float(20) %}\n\n    {% set new_state = value_temperature_sensor | float(current_temp)
    %}\n    {% set old_state = states(calibration_entity) | float %}\n\n    {% if
    is_aggressive_mode_calibration %}           \n      {% set temp_diff = state_attr(valve,'temperature')
    | float(target_temperature) - value_temperature_sensor | float %}\n\n      {%
    if temp_diff * factor < input_aggressive_mode_range * -1 %}\n        {% set new_state
    = new_state + input_aggressive_mode_offset * factor %}\n      {% elif temp_diff
    * factor > input_aggressive_mode_range %}\n        {% set new_state = new_state
    - input_aggressive_mode_offset * factor %}\n      {% endif %}\n    {% endif %}\n\n
    \   {% if step <= 1 and max_val | string | count < 4 %}\n      {% set round_size
    = iif('.' in (step | string), (step | string).split('.')[1] | length, 0) %}\n
    \     {% set new_state = ((new_state | float(0) / step) | round(0) * step) | round(round_size)
    | float %}\n    {% else %}\n      {% set new_state = new_state * 100 | int %}\n
    \     {% set old_state = old_state | int %}\n    {% endif %}\n\n    {% set update_calibration
    = old_state != new_state %}\n\n    {% if is_periodical_popp_calibration and not
    update_calibration %}\n      {% set last_updated = [calibration_entity] | expand
    | map(attribute='last_updated') | first %}\n      {% set update_calibration =
    as_datetime(current_time_stamp) - timedelta(minutes=20) >= last_updated %}\n    {%
    endif %}\n\n    {% if update_calibration %}\n      {% set n.dict = n.dict + [(calibration_entity,
    [{'value': new_state, 'valve': valve}])] %}\n    {% endif%}\n\n  {% endfor %}\n{%
    endif %}\n{{ dict.from_keys(n.dict) }}\n"
  calibration_common: "{% set n = namespace(dict=[]) %}\n{% if is_native_calibration_trigger
    %}\n\n  {% for valve in valves_calibration_common %}\n\n    {% set calibration_entities
    = device_entities(device_id(valve)) |\n                                expand
    | selectattr('domain','in','number') |\n                                selectattr('entity_id',
    'search', input_calibration_key_word) |\n                                map(attribute='entity_id')
    | list %}\n\n    {% if calibration_entities | count > 0%}\n\n      {% set calibration_entity
    = calibration_entities | first %}\n      \n      {% set step = state_attr(calibration_entity,
    'step') | float(1) %}\n      {% if rounding_mode == 'manual' %} \n          {%
    set step = input_calibration_step_size | float(1) %}\n      {% endif %}\n\n      {%
    set min_calibration_value = state_attr(calibration_entity,'min') | float %}\n
    \     {% set max_calibration_value = state_attr(calibration_entity,'max') | float
    %}\n      {% set thermostat_temperature = state_attr(valve, 'current_temperature')
    | float %}\n      {% set offset_old = states(calibration_entity) | float(0) %}\n\n
    \     {% set new_calibration_value = (-(thermostat_temperature - value_temperature_sensor)
    + offset_old) %}\n\n      {% if is_aggressive_mode_calibration %}           \n
    \       {% set temp_diff = state_attr(valve,'temperature') | float(target_temperature)
    - value_temperature_sensor %}\n\n        {% if temp_diff * factor < input_aggressive_mode_range
    * -1 %}\n          {% set new_calibration_value = new_calibration_value + input_aggressive_mode_offset
    * factor %}\n        {% elif temp_diff * factor > input_aggressive_mode_range
    %}\n          {% set new_calibration_value = new_calibration_value - input_aggressive_mode_offset
    * factor %}\n        {% endif %}\n      {% endif %}\n\n      {% set new_calibration_value
    = iif(new_calibration_value > max_calibration_value, max_calibration_value, new_calibration_value)
    %}\n      {% set new_calibration_value = iif(new_calibration_value < min_calibration_value,
    min_calibration_value, new_calibration_value) %}\n\n      {% set round_size =
    iif('.' in (step | string), (step | string).split('.')[1] | length, 0) %}\n\n
    \     {% set offset_new = ((new_calibration_value | float(0) / step) | round(0)
    * step) | round(round_size) | float %}\n\n      {% if (float(offset_old) - float(offset_new))
    | abs >= float(input_calibration_delta) %}\n        {% set n.dict = n.dict + [(calibration_entity,
    [{'value': offset_new, 'valve': valve}])] %}\n      {% endif %}\n\n    {% endif
    %}\n\n  {% endfor %}\n{% endif %}\n{{ dict.from_keys(n.dict) }}\n"
  calibration_value_set: '{{ dict(dict(calibration_xiaomi, **calibration_dph),**calibration_common)
    }}'
  no_changes: "{{ \n  (input_persons | count == 0 and \n  input_mode_guest == none
    and \n  input_schedulers | count == 0 and \n  input_presence_sensor == none and
    \n  input_proximity == none) or\n  (is_temperature_sensor_defined and not valid_temperature_sensor)\n}}\n"
  scene_trigger: '{{ is_scene_create_trigger or is_scene_apply_trigger or is_scene_destroy_trigger
    }}'
  change_trigger: '{{ is_changes_trigger and not scene_trigger and changes | count
    > 0 and not no_changes}}'
  reset_trigger: '{{ is_reset_trigger and not no_changes }}'
  calibration_trigger: '{{ is_calibration_trigger and not input_calibration_generic
    and (calibration_value_set | count > 0 or calibration_tado | count > 0) }}'
  positioning_trigger: '{{ positioning | count > 0 }}'
  automation_name: '{{ state_attr(this.entity_id,''friendly_name'') }}'
  warnings: "{% set messages = [] %} {% if not is_uptime_defined %}\n  {% set messages
    = messages + ['To make Advance Heating Control work properly just setup the uptime
    integration (https://www.home-assistant.io/integrations/uptime/)'] %}\n{% elif
    is_aggressive_mode and not input_aggressive_mode_calibration and is_physical_change_enabled
    %}\n  {% set messages = messages + ['Aggressive Mode in combination with physical
    change / sync feature is not recommended. Expect unwanted side effects.'] %}\n{%
    elif is_generic_calibration and is_physical_change_enabled %}\n  {% set messages
    = messages + ['Generic Calibration in combination with physical change / sync
    feature is not recommended. Expect unwanted side effects.'] %}\n{% elif valves_unsupported
    | count > 0 %}\n  {% set messages = messages + ['Unsupported climate entities:
    ' + valves_unsupported | join(',') | string ] %}\n{% elif is_temperature_sensor_defined
    and not valid_temperature_sensor %}\n  {% set messages = messages + ['The temperature
    sensor' + input_temperature_sensor + ' has an invalid state: ' + states(input_temperature_sensor)
    ] %}\n{% endif %}\n{{ messages }}\n"
  climates_information: "{% set n = namespace(dict=[]) %}\n{% for valve in input_trvs
    %}\n  {% set temperature = state_attr(valve,'temperature') %}\n  {% set current_temperature
    = state_attr(valve,'current_temperature') %}\n  {% set state = states(valve) %}\n
    \ {% set n.dict = n.dict + [{'entity_id': valve, 'state': state, 'temperature':
    temperature, 'current_temperature': current_temperature}] %}\n{% endfor %}\n{{
    n.dict }}\n"
conditions:
- condition: or
  conditions:
  - condition: template
    value_template: '{{ calibration_trigger }}'
  - condition: template
    value_template: '{{ scene_trigger }}'
  - condition: template
    value_template: '{{ change_trigger }}'
  - condition: template
    value_template: '{{ reset_trigger }}'
  - condition: template
    value_template: '{{ positioning_trigger }}'
actions:
- variables:
    is_delayed: '{{ not (not is_uptime_defined or (now() | as_datetime - states(up_time_sensor)
      | as_datetime) > timedelta(**input_startup_delay)) }}'
- action: system_log.write
  data:
    message: '{{ ''AHC - '' + automation_name | string  + '' \n '' + ''automation
      delayed: '' + is_delayed | string }}

      '
    level: !input input_log_level
    logger: blueprints.panhans.heatingcontrol
- wait_template: '{{ not is_uptime_defined or (now() | as_datetime - states(up_time_sensor)
    | as_datetime) > timedelta(**input_startup_delay) }}

    '
- choose:
  - conditions: '{{ is_delayed }}'
    sequence:
    - event: ahc_delay_event
      event_data:
        automation: '{{ this.entity_id }}'
  default:
  - if:
    - condition: template
      value_template: '{{ warnings | count > 0 }}'
    then:
    - action: system_log.write
      data:
        level: warning
        logger: blueprints.panhans.heatingcontrol
        message: '{{ ''AHC-Warnings - '' + automation_name + '':\n'' + warnings |
          join(''\n'') }}

          '
  - event: ahc_event
    event_data:
      state: '{{ state_ahc }}'
      mode: '{{ iif(set_comfort == true, ''comfort'', ''eco'') }}'
      automation: '{{ this.entity_id }}'
      is_person_defined: '{{ is_person_defined }}'
      is_anybody_home: '{{ is_anybody_home }}'
      is_proximity_defined: '{{ is_proximity_defined }}'
      is_anybody_home_or_proximity: '{{ is_anybody_home_or_proximity }}'
      is_guest_mode: '{{ is_guest_mode }}'
      active_scheduler: '{{ active_scheduler }}'
      state_scheduler: '{{ state_scheduler }}'
      state_presence_sensor: '{{ state_presence_sensor }}'
      state_presence_scheduler: '{{ state_presence_scheduler }}'
      state_presence: '{{ state_presence }}'
      state_proximity_arrived: '{{ state_proximity_arrived }}'
      state_proximity_way_home: '{{ state_proximity_way_home }}'
      is_force_max_temperature: '{{ is_force_max_temperature }}'
      is_force_eco_temperature: '{{ is_force_eco_temperature }}'
      active_party_entity: '{{ active_party_entity }}'
      party_temp: '{{ party_temp }}'
      is_away: '{{ is_away }}'
      state_window: '{{ state_window }}'
      is_aggressive_mode: '{{ is_aggressive_mode }}'
      is_frost_protection: '{{ is_frost_protection }}'
      is_liming_protection: '{{ is_liming_protection }}'
      state_outside_temp: '{{ state_outside_temp }}'
      entry_time: '{{ entry_time }}'
      thermostats: '{{ input_trvs }}'
      hvac_mode: '{{ mode }}'
      temperature_comfort: '{{ temperature_comfort }}'
      temperature_eco: '{{ temperature_eco }}'
      target_temperature: '{{ target_temperature }}'
      set_max_temperature: '{{ set_max_temperature }}'
      last_trigger_id: '{{ iif(trigger_id_defined, trigger.id, '''') }}'
      calibration_trigger: '{{ is_generic_calibration_trigger or calibration_trigger
        }}'
      change_trigger: '{{ change_trigger }}'
      warnings: '{{ warnings | count > 0 }}'
  - if:
    - condition: template
      value_template: '{{ calibration_trigger }}'
    - condition: and
      conditions: !input input_custom_condition_calibration
    then:
    - action: system_log.write
      data:
        message: '{{ ''AHC - Calibration - '' + automation_name | string  + '' \n
          '' + ''calibration data set: '' + calibration_value_set | string }}

          '
        level: !input input_log_level
        logger: blueprints.panhans.heatingcontrol
    - repeat:
        count: '{{ calibration_value_set | count | int }}'
        sequence:
        - variables:
            index: '{{ repeat.index-1 }}'
            calibration_entity: '{{ (calibration_value_set.keys() | list) [index]
              }}'
            thermostat: '{{ (((calibration_value_set.values() | list) [index]) | first)
              [''valve''] }}'
            offset: '{{ (((calibration_value_set.values() | list) [index]) | first)
              [''value''] }}'
            select_entity: '{{ device_entities(device_id(thermostat)) | expand | selectattr(''domain'',''in'',''select'')
              | selectattr(''attributes.options'', ''contains'', ''external'') | map(attribute=''entity_id'')
              | list | first | default(none) }}'
        - action: system_log.write
          data:
            message: '{{ ''AHC - Calibration - '' + automation_name | string  + ''
              \n '' + ''calibration entity: '' + calibration_entity | string  + ''
              \n '' + ''offset: '' + offset | string }}

              '
            level: !input input_log_level
            logger: blueprints.panhans.heatingcontrol
        - if:
          - condition: template
            value_template: '{{ thermostat in valves_xiaomi }}'
          - condition: template
            value_template: '{{ select_entity != none and not is_state(select_entity,
              ''external'') }}'
          then:
          - action: select.select_option
            target:
              entity_id: '{{ select_entity }}'
            data:
              option: external
          - delay: !input input_action_call_delay
        - action: number.set_value
          data:
            value: '{{ float(offset) }}'
          target:
            entity_id: '{{ calibration_entity }}'
        - delay: !input input_action_call_delay
    - repeat:
        count: '{{ calibration_tado | count | int }}'
        sequence:
        - variables:
            index: '{{ repeat.index-1 }}'
            thermostat: '{{ (calibration_tado.keys() | list) [index] }}'
            offset: '{{ (((calibration_tado.values() | list) [index]) | first) [''value'']
              }}'
        - action: '{{ ''tado.set_climate_temperature_offset'' }}'
          data:
            offset: '{{ offset }}'
            entity_id: '{{ thermostat }}'
        - delay: !input input_action_call_delay
  - if:
    - condition: template
      value_template: '{{ positioning_trigger }}'
    then:
    - repeat:
        count: '{{ positioning | count | int }}'
        sequence:
        - variables:
            index: '{{ repeat.index-1 }}'
            thermostat: '{{ (positioning.keys() | list) [index] }}'
            positioning_value: '{{ (((positioning.values() | list) [index]) | first)
              [''value''] }}'
            positioning_entity: '{{ (((positioning.values() | list) [index]) | first)
              [''entity''] }}'
        - action: system_log.write
          data:
            message: '{{ ''AHC - Positioning - '' + automation_name | string  + ''
              \n '' + ''entity: '' + positioning_entity | string  + '' \n '' + ''value:
              '' + positioning_value | string }}

              '
            level: !input input_log_level
            logger: blueprints.panhans.heatingcontrol
        - action: number.set_value
          data:
            value: '{{ positioning_value | int }}'
          target:
            entity_id: '{{ positioning_entity }}'
        - delay: !input input_action_call_delay
  - if:
    - condition: template
      value_template: '{{ is_scene_create_trigger }}'
    - condition: template
      value_template: '{{ states[scene_to_create] == none }}'
    then:
    - action: scene.create
      data:
        snapshot_entities: '{{ scene_entities }}'
        scene_id: '{{ scene_to_create.split(''.'')[1] }}'
  - if:
    - condition: template
      value_template: '{{ is_scene_destroy_trigger }}'
    - condition: template
      value_template: '{{ scenes_to_destroy | count > 0 }}'
    then:
    - repeat:
        count: '{{ scenes_to_destroy | count | int }}'
        sequence:
        - variables:
            scene_to_destroy: '{{ scenes_to_destroy[repeat.index-1] }}'
        - if:
          - condition: template
            value_template: '{{ states[scene_to_destroy] != none }}'
          then:
          - action: scene.delete
            target:
              entity_id: '{{ scene_to_destroy }}'
  - variables:
      scene_to_apply_tmp: "{% if scene_to_apply != none and states[scene_to_apply]
        != none %}\n  {{ scene_to_apply }}\n{% else %}\n  {{ scenes_all | expand |
        reject('==',none) | map(attribute=\"entity_id\") | list | first | default(none)
        }}\n{% endif %}\n"
  - if:
    - condition: template
      value_template: '{{ is_scene_apply_trigger }}'
    - condition: template
      value_template: '{{ scene_to_apply_tmp != none and states[scene_to_apply_tmp]
        != none }}'
    then:
    - action: system_log.write
      data:
        message: '{{ ''AHC - Calibration - '' + automation_name | string + '' \n ''
          + ''apply scene: '' + scene_to_apply_tmp | string + '' state: '' + states[scene_to_apply_tmp]
          | string }}

          '
        level: !input input_log_level
        logger: blueprints.panhans.heatingcontrol
    - action: scene.turn_on
      target:
        entity_id: '{{ scene_to_apply_tmp }}'
    - action: scene.delete
      target:
        entity_id: '{{ scene_to_apply_tmp }}'
    - condition: template
      value_template: '{{ false }}'
    else:
    - if:
      - condition: template
        value_template: '{{ is_reset_trigger }}'
      then:
      - repeat:
          count: '{{ reset_data | count | int }}'
          sequence:
          - action: system_log.write
            data:
              message: '{{ ''AHC - Calibration - '' + automation_name | string  +
                '' \n '' + ''reset data: '' + reset_data | string }}

                '
              level: !input input_log_level
              logger: blueprints.panhans.heatingcontrol
          - variables:
              index: '{{ repeat.index-1 }}'
              reset_entity: '{{ reset_data[index][''entity''] }}'
              reset_temp: '{% set temp_r = reset_data[index][''temp''] %} {% set t_min
                = state_attr(reset_entity,''min'') %} {% set t_max = state_attr(reset_entity,''max'')
                %} {% set step = state_attr(reset_entity,''step'') %}

                {% set temp_r = ((temp_r | float(0) / step) | round(0) * step) | float
                %} {% set temp_r = iif(temp_r > t_max, t_max, temp_r) %} {% set temp_r
                = iif(temp_r < t_min, t_min, temp_r) %} {{ temp_r }}

                '
          - action: input_number.set_value
            data:
              value: '{{ reset_temp }}'
            target:
              entity_id: '{{ reset_entity }}'
    - if:
      - condition: and
        conditions: !input input_custom_condition
      - condition: template
        value_template: '{{ changes | count | int > 0 }}'
      then:
      - repeat:
          count: '{{ changes | count | int }}'
          sequence:
          - variables:
              index: '{{ repeat.index-1 }}'
              thermostat: '{{ (changes.keys() | list) [index] }}'
              mode: '{{ (((changes.values() | list) [index]) | first) [''mode''] }}'
              temp_target: '{{ (((changes.values() | list) [index]) | first) [''temp'']
                }}'
          - action: system_log.write
            data:
              message: 'AHC - Change - {{ automation_name }} {{" \n "}} Trigger ID:
                {{ iif(trigger_id_defined, trigger.id, '''') }} Thermostat: {{ thermostat
                }} {{" \n "}} Mode: {{ mode }} {{" \n "}} New Target Temp: {{ temp_target
                }} {{" \n "}} Current Target Temp: {{ state_attr(thermostat,''temperature'')
                }}

                '
              level: !input input_log_level
              logger: blueprints.panhans.heatingcontrol
          - if:
            - condition: template
              value_template: '{{ states(thermostat) | lower != mode | lower  }}'
            then:
            - action: climate.set_hvac_mode
              data:
                entity_id: '{{ thermostat }}'
                hvac_mode: '{{ mode }}'
            - delay: !input input_action_call_delay
          - if:
            - condition: template
              value_template: '{{ state_attr(thermostat, ''temperature'') != temp_target
                and mode != ''off'' }}'
            then:
            - action: climate.set_temperature
              data:
                entity_id: '{{ thermostat }}'
                temperature: '{{ temp_target | float }}'
            - delay: !input input_action_call_delay
  - if:
    - condition: template
      value_template: '{{ input_custom_action != none }}'
    then: !input input_custom_action
mode: queued
